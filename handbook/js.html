<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS基础语法相关 | 学习文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习文档">
    
    <link rel="preload" href="/learn/assets/css/0.styles.889b6c4e.css" as="style"><link rel="preload" href="/learn/assets/js/app.250e2cfc.js" as="script"><link rel="preload" href="/learn/assets/js/3.51ab3639.js" as="script"><link rel="preload" href="/learn/assets/js/1.504525ea.js" as="script"><link rel="preload" href="/learn/assets/js/12.bfc5c243.js" as="script"><link rel="prefetch" href="/learn/assets/js/10.a365623c.js"><link rel="prefetch" href="/learn/assets/js/11.d1d61896.js"><link rel="prefetch" href="/learn/assets/js/13.ba90bc7d.js"><link rel="prefetch" href="/learn/assets/js/4.f2ad145d.js"><link rel="prefetch" href="/learn/assets/js/5.acb9c427.js"><link rel="prefetch" href="/learn/assets/js/6.bf0398c6.js"><link rel="prefetch" href="/learn/assets/js/7.36bc8eb5.js"><link rel="prefetch" href="/learn/assets/js/8.43b324b6.js"><link rel="prefetch" href="/learn/assets/js/9.278d5231.js">
    <link rel="stylesheet" href="/learn/assets/css/0.styles.889b6c4e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-5bb33761><div data-v-5bb33761><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-5bb33761 data-v-5bb33761><h3 class="title" data-v-59e6cb88>学习文档</h3> <p class="description" data-v-59e6cb88>学习文档</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2022
      </a></span></div></div> <div class="hide" data-v-5bb33761><header class="navbar" data-v-5bb33761><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn/" class="home-link router-link-active"><!----> <span class="site-name">学习文档</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learn/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      mxy的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3998283094559166" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-5bb33761></div> <aside class="sidebar" data-v-5bb33761><div class="personal-info-wrapper" data-v-1fad0c41 data-v-5bb33761><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>4</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/learn/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      mxy的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3998283094559166" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/learn/" class="sidebar-heading clickable router-link-active"><span>欢迎学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn/" aria-current="page" class="sidebar-link">学前必读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/learn/handbook/ConditionalTypes" class="sidebar-heading clickable open"><span>基础学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn/handbook/Array.html" class="sidebar-link">数组方法</a></li><li><a href="/learn/handbook/js.html" aria-current="page" class="active sidebar-link">Js面试题</a></li><li><a href="/learn/handbook/vue.html" class="sidebar-link">vue面试题</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-5bb33761><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2022
      </a></span></div></div> <div data-v-5bb33761><div data-v-5bb33761><main class="page" style="padding-right:0;"><section style="display:;"><div class="page-title"><h1 class="title">JS基础语法相关</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="js基础语法相关"><a href="#js基础语法相关" class="header-anchor">#</a> JS基础语法相关</h1> <h2 id="问题1-js的数据类型-存储上的差别"><a href="#问题1-js的数据类型-存储上的差别" class="header-anchor">#</a> 问题1：js的数据类型，存储上的差别？</h2> <h3 id="目标"><a href="#目标" class="header-anchor">#</a> 目标</h3> <ul><li>在<code>JavaScript</code>中，我们可以分成两种类型：基本类型、复杂类型</li> <li>要掌握两种类型的在内存上存储不同！</li></ul> <h3 id="讲解"><a href="#讲解" class="header-anchor">#</a> 讲解</h3> <ul><li>基本类型：
<ul><li>基本类型主要为以下7种：Number、String、Boolean、BigInt、Symbol、Null、Undefined、</li> <li>Null<code>类型同样只有一个值，即特殊值</code>null；null 值表示一个空对象指针，这也是给<code>typeof</code>传一个 <code>null</code> 会返回 <code>&quot;object&quot;</code> 的原因</li> <li><code>undefined</code> 值是由 <code>null</code>值派生而来  <code>console.log(null == undefined); // true</code></li> <li>Symbol是ES6新出的一种数据类型，这种数据类型的特点就是没有重复的数据，可以作为object的key。</li></ul></li> <li>引用类型
<ul><li>3种：Object、Array、Function</li> <li>函数实际上是对象，每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code>也有属性和方法，跟其他引用类型一样</li></ul></li> <li>存储区别：
<ul><li>基本数据类型存储在<strong>栈</strong>中
<ul><li>基本数据类型是直接存储在栈中的简单数据段，占据空间小，属于被频繁使用的数据。</li></ul></li> <li>引用类型的对象存储于<strong>堆</strong>中
<ul><li>引用数据类型是存储在堆内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul></li></ul></li></ul> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <ul><li>记忆：存储区别！</li> <li>记忆：简单类型中null说明、引用类型里面function的说明！</li></ul> <h2 id="问题2-和-区别"><a href="#问题2-和-区别" class="header-anchor">#</a> 问题2：== 和 ===区别？</h2> <h3 id="目标-2"><a href="#目标-2" class="header-anchor">#</a> 目标</h3> <ul><li>知道== 和 ===区别核心区别，以及部分比较前隐式转换的规则</li></ul> <h3 id="讲解-2"><a href="#讲解-2" class="header-anchor">#</a> 讲解</h3> <ul><li>** ==**
<ul><li>在比较中会先进行类型转换，再确定操作数是否相等</li> <li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等</li> <li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等</li> <li>如果一个操作数是对象，另一个操作数不是，则调用对象的 <code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较 <code>let obj = {valueOf:function(){return 1}} let result1 = (obj == 1); // true</code></li> <li><code>let result1 = (null == undefined ); // true</code></li> <li>如果有任一操作数是 <code>NaN</code> ，则相等操作符返回 <code>false</code></li> <li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回<code>true</code></li></ul></li> <li>** ===**
<ul><li>全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</li> <li><code>undefined</code> 和 <code>null</code> 与自身严格相等 <code>let result2 = (undefined === undefined) //true</code></li></ul></li></ul> <h3 id="小结-2"><a href="#小结-2" class="header-anchor">#</a> 小结</h3> <p><strong>==</strong></p> <ul><li>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</li> <li>简单类型与引用类型比较，对象转化成其原始类型的值，再比较</li> <li>两个都为引用类型，则比较它们是否指向同一个对象</li> <li>null 和 undefined 相等</li> <li>存在 NaN 则返回 false</li></ul> <p><strong>===</strong></p> <ul><li>如果数据类型不一样，直接false；</li> <li>特别：<code>let result2 = (undefined === undefined) //true</code></li></ul> <h2 id="问题3-深拷贝浅拷贝的区别-如何实现一个深拷贝"><a href="#问题3-深拷贝浅拷贝的区别-如何实现一个深拷贝" class="header-anchor">#</a> 问题3：深拷贝浅拷贝的区别？如何实现一个深拷贝？</h2> <h3 id="目标-3"><a href="#目标-3" class="header-anchor">#</a> 目标</h3> <ul><li>能说出深拷贝浅拷贝的定义区别</li> <li>会实现深拷贝</li></ul> <h3 id="讲解-3"><a href="#讲解-3" class="header-anchor">#</a> 讲解</h3> <p>首先浅拷贝和深拷贝只针对引用类型</p> <ul><li>浅拷贝： （对象中的简单类型拷贝值，复杂类型拷贝的是地址（简单理解： 如果是单层对象，没问题，如果有多层就有问题)</li> <li>）
<ul><li>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝.</li> <li>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址；即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</li></ul></li> <li>深度拷贝
<ul><li>对比浅拷贝，如果属性是引用类型，深拷贝在内存中开辟一块新的地址用于存放复制的对象，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性！</li></ul></li> <li>实现深度拷贝：手写递归</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">newObj<span class="token punctuation">,</span>oldObj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//（新数据，被拷贝数据）</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> oldObj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 如果数据类型是数组，必须写在最上面，</span>
            <span class="token comment">// 因为 ( [1,2] instanceof Object === true)</span>
            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token function">deepCopy</span><span class="token punctuation">(</span>newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//如果数据是对象类型</span>
            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token function">deepCopy</span><span class="token punctuation">(</span>newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token comment">//数据是基本数据类型</span>
            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newObj
<span class="token punctuation">}</span>
</code></pre></div><h3 id="小结-3"><a href="#小结-3" class="header-anchor">#</a> 小结</h3> <ul><li>对于一个引用数据类型，实现拷贝第一层，就是浅拷贝，实现每层键值对拷贝，就是深度拷贝；</li> <li>要会手写递归实现深度拷贝！</li></ul> <h2 id="问题4-什么是闭包"><a href="#问题4-什么是闭包" class="header-anchor">#</a> 问题4：什么是闭包？</h2> <h3 id="目标-4"><a href="#目标-4" class="header-anchor">#</a> 目标</h3> <ul><li>知道什么情况下是闭包，闭包会有什么特点？</li></ul> <h3 id="讲解-4"><a href="#讲解-4" class="header-anchor">#</a> 讲解</h3> <ul><li>闭包让你可以在一个内层函数中访问到其外层函数的作用域</li> <li>基本形式：内存函数使用了外层函数的变量，构成闭包！</li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22014993/1657202428528-5615b3cd-3f8e-45fa-93c5-5f93e9d938ae.png#clientId=u4afc02fb-6a9b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=154&amp;id=uf0846fb6&amp;name=image.png&amp;originHeight=261&amp;originWidth=962&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65315&amp;status=done&amp;style=none&amp;taskId=u532f4497-8eef-4702-b0b6-3b516d4afdb&amp;title=&amp;width=566" alt="image.png"></p> <ul><li>特点：一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">function</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数执行完了，</span>


    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> fn<span class="token punctuation">;</span>
    <span class="token comment">// 但是点击的时候，50的设置值还在，50随着fn的函数一起留在在内存上！</span>
    <span class="token comment">// 页面不关闭，50这个数据就一直停留在内存上！</span>
</code></pre></div><h3 id="小结-4"><a href="#小结-4" class="header-anchor">#</a> 小结</h3> <ul><li>形式：内存函数使用了外层函数的变量！</li> <li>特点：外层函数执行完后，由于内存函数使用了外层的变量，该变量不会被销毁，而是停留在内存上！</li></ul> <h2 id="问题5-什么是作用域链"><a href="#问题5-什么是作用域链" class="header-anchor">#</a> 问题5：什么是作用域链？</h2> <h3 id="目标-5"><a href="#目标-5" class="header-anchor">#</a> 目标</h3> <ul><li>知道什么是作用域链，有什么作用？</li></ul> <h3 id="讲解-5"><a href="#讲解-5" class="header-anchor">#</a> 讲解</h3> <ul><li>当在<code>Javascript</code>中使用一个变量的时候，首先<code>Javascript</code>引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域</li> <li>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错</li> <li>词法作用域：词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，<code>JavaScript</code> 遵循的就是词法作用域！</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22014993/1657202469539-7506e2fc-7c55-4bc3-872b-0665d57d37f7.png#clientId=u4afc02fb-6a9b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=388&amp;id=udbd431c7&amp;name=image.png&amp;originHeight=663&amp;originWidth=1062&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=134045&amp;status=done&amp;style=none&amp;taskId=u3dd22db5-eb8f-4325-94dc-6dffd763d3b&amp;title=&amp;width=621" alt="image.png"></p> <ul><li>由于<code>JavaScript</code>遵循词法作用域，<strong>相同层级</strong>的 <code>foo</code> 和 <code>bar</code> 就没有办法访问到彼此块作用域中的变量，所以输出2</li></ul> <h3 id="小结-5"><a href="#小结-5" class="header-anchor">#</a> 小结</h3> <ul><li>先在当前作用域寻找该变量，找不到就往外层，直到全局作用域，</li> <li>再找不到就报错！</li></ul> <h2 id="问题6-什么是原型链"><a href="#问题6-什么是原型链" class="header-anchor">#</a> 问题6：什么是原型链 ?</h2> <h3 id="目标-6"><a href="#目标-6" class="header-anchor">#</a> 目标</h3> <ul><li>知道什么是原型链，原型链的意义是什么！</li></ul> <h3 id="讲解-6"><a href="#讲解-6" class="header-anchor">#</a> 讲解</h3> <ul><li><code>JavaScript</code> 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</li> <li>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</li> <li>准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的<code>prototype</code>属性上，而非实例对象本身</li> <li>代码及图示</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token parameter">info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> info<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Some</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">fn1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;我是  Some.prototype  的上的方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;我是  Object.prototype  的上的方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token string">&quot;测试实例化test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

test<span class="token punctuation">.</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>方法的执行，都是顺序对象及原型对象这个链找下，直到匹配到位！</li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22014993/1657202500762-db455a1f-4c8e-47ed-aeae-602d4b2bc0c5.png#clientId=u4afc02fb-6a9b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=379&amp;id=ua7435340&amp;name=image.png&amp;originHeight=611&amp;originWidth=784&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=139725&amp;status=done&amp;style=none&amp;taskId=u5796891d-6b07-49d5-b3c9-21e39515fed&amp;title=&amp;width=486.20001220703125" alt="image.png"></p> <h2 id="问题7-关于this指向的理解"><a href="#问题7-关于this指向的理解" class="header-anchor">#</a> 问题7：关于this指向的理解？</h2> <h3 id="目标-7"><a href="#目标-7" class="header-anchor">#</a> 目标</h3> <ul><li>知道不同的调用函数的方式，内部的this指向是不同的！</li></ul> <h3 id="讲解-7"><a href="#讲解-7" class="header-anchor">#</a> 讲解</h3> <ul><li>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</li> <li>代码：</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window;</span>


document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#btn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> fn<span class="token punctuation">;</span> <span class="token comment">// dom节点</span>


<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// {}</span>


<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">)</span> <span class="token comment">// Math</span>


<span class="token keyword">let</span> newfn <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">newfn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// []</span>


<span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f实例化对象</span>
</code></pre></div><h3 id="小结-6"><a href="#小结-6" class="header-anchor">#</a> 小结</h3> <ul><li>简单来说：就是谁调用就是谁！</li></ul> <h2 id="问题8-事件委托的实现原理是什么"><a href="#问题8-事件委托的实现原理是什么" class="header-anchor">#</a> 问题8：事件委托的实现原理是什么？</h2> <h3 id="目标-8"><a href="#目标-8" class="header-anchor">#</a> 目标</h3> <ul><li>能够描述事件委托背后的实现原理</li></ul> <h3 id="讲解-8"><a href="#讲解-8" class="header-anchor">#</a> 讲解</h3> <ul><li>原理：因为事件默认是在冒泡阶段执行的！</li> <li>比如：当子元素被用户点击了，父级元素设置点击事件的执行函数，那么点击子元素，父级元素的执行函数会被执行！</li> <li>应用：如果有很多子元素都需要注册同一种事件类型，那么该事件的执行函数可以委托给父级，也就是注册给父级；
<ul><li>优点：节省内存、实现动态元素的事件注册</li> <li>缺点：所有的子元素的业务都需要写在一个函数内部，执行起来时，耗费性能！</li></ul></li></ul> <h3 id="小结-7"><a href="#小结-7" class="header-anchor">#</a> 小结</h3> <ul><li>原理：事件默认是在冒泡阶段执行的！</li> <li>优点：节省内存、实现动态元素的事件注册</li> <li>缺点：所有的子元素的业务都需要写在一个函数内部，执行起来时，耗费性能！</li></ul> <h2 id="问题9-typeof-与-instanceof-区别"><a href="#问题9-typeof-与-instanceof-区别" class="header-anchor">#</a> 问题9：typeof 与 instanceof 区别？</h2> <h3 id="小结-8"><a href="#小结-8" class="header-anchor">#</a> 小结</h3> <ul><li>知道typeof、instanceof 的用法及区别</li></ul> <h3 id="讲解-9"><a href="#讲解-9" class="header-anchor">#</a> 讲解：</h3> <ul><li>typeof：
<ul><li>前6个都是基础数据类型。虽然<code>typeof null</code>为<code>object</code>，但这只是<code>JavaScript</code> 存在的一个悠久 <code>Bug</code>，不代表<code>null</code>就是引用数据类型，并且<code>null</code>本身也不是对象</li> <li>所以，<code>null</code>在 <code>typeof</code>之后返回的是有问题的结果，不能作为判断<code>null</code>的方法。如果你需要在 <code>if</code> 语句中判断是否为 <code>null</code>，直接通过<code>===null</code>来判断就好</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment">// 'number'</span>
<span class="token keyword">typeof</span> <span class="token string">'1'</span> <span class="token comment">// 'string'</span>
<span class="token keyword">typeof</span> <span class="token keyword">undefined</span> <span class="token comment">// 'undefined'</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment">// 'boolean'</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'symbol'</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> console <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment">// 'function'</span>
</code></pre></div><ul><li><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义构建函数</span>
<span class="token keyword">let</span> <span class="token function-variable function">Car</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> benz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
benz <span class="token keyword">instanceof</span> <span class="token class-name">Car</span> <span class="token comment">// true</span>
<span class="token keyword">let</span> car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span>
car <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// true</span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'xxx'</span>
str <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// false</span>
</code></pre></div><ul><li>关于<code>instanceof</code>的实现原理，可以参考下面：</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里先用typeof来判断基础数据类型，如果是，直接返回false</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> left <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span>
    <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  
        <span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//找到相同原型对象，返回true</span>
        proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeof</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="小结-9"><a href="#小结-9" class="header-anchor">#</a> 小结</h3> <ul><li>typeof不是很方便判断引用数据类型</li> <li>instanceof：
<ul><li>某对象是否为某构造函数类型的实例化对象</li> <li>某对象是否继承了某构造函数的原型对象</li></ul></li></ul> <h2 id="问题10-new操作符具体干了什么"><a href="#问题10-new操作符具体干了什么" class="header-anchor">#</a> 问题10：new操作符具体干了什么？</h2> <h3 id="目标-9"><a href="#目标-9" class="header-anchor">#</a> 目标</h3> <ul><li>知道new这个关键字配合构造函数进行实例化的时候，做了什么</li></ul> <h3 id="讲解-10"><a href="#讲解-10" class="header-anchor">#</a> 讲解</h3> <ul><li>例子</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span> <span class="token comment">// Person {name: &quot;Tom&quot;, age: 20}</span>
person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'Tom'</span>
</code></pre></div><ul><li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数中的属性</li> <li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）</li> <li>理解代码：</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
        name<span class="token punctuation">,</span>
        age
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// new 做的事情：</span>
<span class="token keyword">let</span> person2 <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1、创建对象</span>
person2<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 2、原型对象关联</span>
</code></pre></div><h3 id="小结-10"><a href="#小结-10" class="header-anchor">#</a> 小结</h3> <ul><li>new<code>通过构造函数</code>Person` 创建出来的实例可以访问到构造函数中的属性</li> <li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）</li></ul> <h2 id="问题11-let-const和var的区别"><a href="#问题11-let-const和var的区别" class="header-anchor">#</a> 问题11: let, const和var的区别?</h2> <h3 id="目标-10"><a href="#目标-10" class="header-anchor">#</a> 目标</h3> <ul><li>掌握这些声明变量关键字区别</li></ul> <h3 id="讲解-11"><a href="#讲解-11" class="header-anchor">#</a> 讲解</h3> <ol><li>ES6中引入let和const以及块级作用域, 目的是为了修复以前变量提升的问题</li> <li>let和const在同一作用域下, 变量名不可以重复, 而var可以</li> <li>let和const在块级作用域下, 而var在function函数作用域下</li> <li>let和const有暂时性死区, 而var有变量提升</li> <li>let和const的全局变量不会挂载到window上, 而var定义的会
| 概念 | let 和 const | var |
| --- | --- | --- |
| 重复声明 | X | √ |
| 作用域 | 块级作用域 | 函数作用域 |
| 变量提升 | 暂时性死区 | √ |
| 挂载到window | X | √ |</li></ol> <h3 id="小结-11"><a href="#小结-11" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>取表格第一列概念, 每个开头第一个字, 组成口诀: 重作变挂
重: 重复声明区别
作: 作用域区别
变: 变量提升区别
挂: 变量是否挂载到window区别</p> <h3 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="http://fanyouf.gitee.io/interview/es6/var_let_const.html" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/es6/var_let_const.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>前端面试宝典V4.0--2022.1</li> <li><a href="https://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener noreferrer">https://es6.ruanyifeng.com/#docs/let<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>极客时间-&gt;浏览器的工作原理与实践</li> <li>mdn: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题12-箭头函数和function函数区别"><a href="#问题12-箭头函数和function函数区别" class="header-anchor">#</a> 问题12: 箭头函数和function函数区别?</h2> <h3 id="目标-11"><a href="#目标-11" class="header-anchor">#</a> 目标</h3> <ul><li>掌握箭头函数和function函数区别</li></ul> <h3 id="讲解-12"><a href="#讲解-12" class="header-anchor">#</a> 讲解</h3> <ol><li>箭头函数无自己this值, 值依赖父级函数作用域this的值</li> <li>箭头函数不能够使用 arguments 对象, 而使用剩余参数运算符</li> <li>箭头函数不能用作构造函数, 不能被new</li></ol> <h3 id="小结-12"><a href="#小结-12" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>箭头函数常用做回调函数使用, 它无自己的this, 无arguments对象, 不能被new调用</p> <h3 id="参考文献-2"><a href="#参考文献-2" class="header-anchor">#</a> 参考文献</h3> <ol><li>前端面试宝典V4.0--2022.1</li> <li><a href="https://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" target="_blank" rel="noopener noreferrer">https://es6.ruanyifeng.com/#docs/function#箭头函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>极客时间-&gt;浏览器工作原理与实践</li></ol> <h2 id="问题13-请实现冒泡排序代码编写"><a href="#问题13-请实现冒泡排序代码编写" class="header-anchor">#</a> 问题13: 请实现冒泡排序代码编写</h2> <h3 id="目标-12"><a href="#目标-12" class="header-anchor">#</a> 目标</h3> <ul><li>掌握冒泡排序基础写法</li> <li>了解冒泡排序进阶写法</li></ul> <h3 id="讲解-13"><a href="#讲解-13" class="header-anchor">#</a> 讲解</h3> <ol><li>基础写法(掌握这个即可)</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> c <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>进阶写法</li></ol> <blockquote><p>从小到达, 只有左侧大于右侧才交换, 外层跑一次, 就把最大的交换到了数组右侧, 所以下次i++后内层循环可以少比较i位, 所以-i</p> <p>而flag作用, 如果发现内存for跑了一圈, 没有交换, 证明数组里顺序已经从小到大, 外层循环无需再执行</p></blockquote> <h3 id="小结-13"><a href="#小结-13" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>如果口述最基础的思路:</p> <ol><li>外层for控制循环比较次数</li> <li>里层for控制遍历元素的下标, 每次拿到j和j+1换出值对比, 然后进入if就交换在数组里元素位置</li></ol> <h3 id="参考文献-3"><a href="#参考文献-3" class="header-anchor">#</a> 参考文献</h3> <ul><li>无 (自己手写)</li></ul> <h2 id="问题14-请实现数组快速去重编写"><a href="#问题14-请实现数组快速去重编写" class="header-anchor">#</a> 问题14: 请实现数组快速去重编写</h2> <h3 id="目标-13"><a href="#目标-13" class="header-anchor">#</a> 目标</h3> <ul><li>掌握常用的数组去重的方法</li> <li>还要会根据业务的不同在此基础上修改</li></ul> <h3 id="讲解-14"><a href="#讲解-14" class="header-anchor">#</a> 讲解</h3> <ol><li>这里有3种常用的可以看看</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 1.使用 es6 set 方法 [...new Set(arr)]</span>
<span class="token comment">// let arr = [1, 2, 3, 4, 3, 2, 3, 4, 6, 7, 6]; </span>
<span class="token comment">// let unique = (arr) =&gt; [...new Set(arr)]; </span>
<span class="token comment">// console.log(unique(arr)); // [1, 2, 3, 4, 6, 7]</span>

<span class="token comment">// 2、利用 filter 和indexOf, 后面的值发现前面能查到, 下标不统一证明存在过, 不被filter收集</span>
<span class="token comment">// let arr = [1, 2, 3, 4, 3, 2, 3, 4, 6, 7, 6]; </span>
<span class="token comment">// let unique = (arr) =&gt; {</span>
<span class="token comment">//     return arr.filter((item, index) =&gt; {</span>
<span class="token comment">//         return arr.indexOf(item) === index;</span>
<span class="token comment">//     })</span>
<span class="token comment">// }; </span>
<span class="token comment">// console.log(unique(arr)) // [1, 2, 3, 4, 6, 7]</span>

<span class="token comment">// 6、利用 Map 数据结构去重</span>
<span class="token comment">// let arr = [1, 2, 3, 4, 3, 2, 3, 4, 6, 7, 6]; </span>
<span class="token comment">// let unique = (arr) =&gt; {</span>
<span class="token comment">//     let seen = new Map(); </span>
<span class="token comment">//     return arr.filter((item) =&gt; {</span>
<span class="token comment">//         // 判断此值在map对象里不存在, 然后给map里添加此元素, 返回true, 被filter收集</span>
<span class="token comment">//         // 如果map里存在了has方法原地为true, !true返回false, 不让filter收集</span>
<span class="token comment">//         return !seen.has(item) &amp;&amp; seen.set(item, 1);</span>
<span class="token comment">//     });</span>
<span class="token comment">// }; </span>
<span class="token comment">// console.log(unique(arr)) // [1, 2, 3, 4, 6, 7]</span>
</code></pre></div><h3 id="小结-14"><a href="#小结-14" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>如果口述最基础的思路:
方式1: 把数组传入到new Set集合中, Set自带元素值去重效果, 再把Set转成数组即可
方式2: 用filter配合indexOf方法, 用遍历的索引和查找的所以比较, 如果相等的则被filter内收集, 不相等证明在前面找到过不让filter收集
方式3: 用filter配合map集合, map集合key为数组的值, value为1标记, 每次遍历判断map上有无, 无则让filter收集遍历的此元素值</p> <h3 id="参考文献-4"><a href="#参考文献-4" class="header-anchor">#</a> 参考文献</h3> <ol><li>前端面试宝典V4.0--2022.1.pdf</li></ol> <h2 id="问题15-什么是promise"><a href="#问题15-什么是promise" class="header-anchor">#</a> 问题15: 什么是Promise?</h2> <h3 id="目标-14"><a href="#目标-14" class="header-anchor">#</a> 目标</h3> <ul><li>介绍Promise特点</li> <li>介绍Promise优缺点</li></ul> <h3 id="讲解-15"><a href="#讲解-15" class="header-anchor">#</a> 讲解</h3> <ol><li>Promise译为承诺，是异步编程的一种解决方案, 承诺在未来有个成功/失败的结果回来</li> <li>它是一个对象, 也是一个容器, 内部一般是一个异步代码, 使用Promise提供的 API，在未来接收成功/失败的结果</li> <li>Promise的出现为了使用链式调用来解决回调地狱问题的, 让异步流程处理的贴近线性结构</li> <li>而且Promise本身是同步的执行对象内代码, then和catch是的回调函数是异步的, 被设计成微任务</li> <li>而Promise内为了保证异步任务结果回来后延迟调用then/catch, 在Promise内维持着三种状态标记</li></ol> <ul><li>等待中 (pending)</li> <li>成功 (fulfilled) -&gt; 也叫兑现</li> <li>失败 (rejected) -&gt; 也叫拒绝</li></ul> <ol start="6"><li>当Promise对象内提供的resolve和reject触发时, 流程如下</li></ol> <ul><li>resolve() 调用后 =&gt; 内部状态为 fulfilled =&gt; 导致then()小括号里的回调函数执行</li> <li>reject()    调用后 =&gt; 内部状态为 rejected =&gt; 导致catch()小括号里的回调函数执行</li></ul> <ol start="7"><li>Promise优点:</li></ol> <ul><li>让回调函数变成链式调用, 流程更清楚</li> <li>它有一些强大的方法, 比如all和race方法, 可等多个异步一起按顺序接收回来结果</li></ul> <ol start="8"><li>Promise缺点:</li></ol> <ul><li>对链式调用要非常熟悉, 编写难度高</li> <li>一旦Promise启动, 无法取消, 无法追踪进度</li> <li>一旦有结果, 状态凝固, 无法再改变, 除非重新创建Promise对象</li></ul> <h3 id="小结-15"><a href="#小结-15" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>方面1: 概念
Promise是一个对象, 它作为容器也是一个承诺，承诺在未来内部异步代码, 有个成功/失败的结果回来, 而且用它的链式调用特点可以解决回调地狱的问题
如果还能说继续↓
方面2: 流程
Promise内部提供resolve和reject2个函数, 有3种状态</p> <ul><li>resolve() 调用后 =&gt; 内部状态为 fulfilled =&gt; 导致then()小括号里的回调函数执行</li> <li>reject()    调用后 =&gt; 内部状态为 rejected =&gt; 导致catch()小括号里的回调函数执行</li></ul> <p>如果还能说继续↓
方面3: 优缺点
Promise优点:</p> <ul><li>让回调函数变成链式调用, 流程更清楚</li> <li>它有一些强大的方法, 比如all和race方法, 可等多个异步一起按顺序接收回来结果</li></ul> <p>Promise缺点:</p> <ul><li>对链式调用要非常熟悉, 编写难度高</li> <li>一旦Promise启动, 无法取消, 无法追踪进度</li> <li>一旦有结果, 状态凝固, 无法再改变, 除非重新创建Promise对象</li></ul> <h3 id="参考文献-5"><a href="#参考文献-5" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="http://fanyouf.gitee.io/interview/es6/promise.html#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/es6/promise.html#一、介绍<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>你不知道的JavaScript</li> <li>极客时间-&gt;浏览器的工作原理与实践</li> <li><a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener noreferrer">https://es6.ruanyifeng.com/#docs/promise<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.csdn.net/tags/NtjaIg0sNTUyNjAtYmxvZwO0O0OO0O0O.html" target="_blank" rel="noopener noreferrer">https://www.csdn.net/tags/NtjaIg0sNTUyNjAtYmxvZwO0O0OO0O0O.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题16-请仿写promise实现"><a href="#问题16-请仿写promise实现" class="header-anchor">#</a> 问题16: 请仿写Promise实现</h2> <h3 id="目标-15"><a href="#目标-15" class="header-anchor">#</a> 目标</h3> <ul><li>了解Promise内部实现的大概过程</li></ul> <h3 id="讲解-16"><a href="#讲解-16" class="header-anchor">#</a> 讲解</h3> <ol><li>代码如下: 按照序号阅读, 和仿写5-10遍</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 如果是要自己模拟一个最基本的</span>
<span class="token comment">// 真正要写全, 代码很长很多, 可以自行百度(有很多)</span>
<span class="token comment">// 这里只模拟个最基础的成功回调</span>

<span class="token comment">// 1. 定义Promise函数</span>
<span class="token keyword">function</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callBackFnArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 2.用来装then小括号里的回调函数, 一会儿回调</span>
    <span class="token keyword">const</span> <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 3. 定义resolve方法, 方法被调用执行这里目的就是为了让then函数执行</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 4. 因为Promise源码是C++写的, 这里只能用setTimeout模拟下延迟, 确保then先被添加后, 再当前resolve调用后再执行then的回调函数</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>callBackFnArr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 5. 给new Promise对象里回调函数, 传递过去resolve方法</span>
    <span class="token function">fn</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 6. 实现Promise构造函数(对象)的实例then方法, 添加到原型对象上可以让所有Promise对象共享</span>
<span class="token class-name">MyPromise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">thenFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">this</span><span class="token punctuation">.</span>callBackFnArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>thenFn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 7. 把外面调用then时传入的回调函数先装入数组中, 等待上面resolve函数调用时, 回调then()小括号里的回调函数执行</span>
<span class="token punctuation">}</span>


<span class="token comment">// 8. 开始模拟使用</span>
<span class="token keyword">let</span> pro <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

pro<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="小结-16"><a href="#小结-16" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>如果口述最基础的思路:
函数内准备数组装then小括号里的回调函数, 再准备resolve方法, 等待此方法调用用, 用定时器模拟延迟执行数组里每个回调函数
再给Promise构造函数上添加then方法, 把收到的回调函数装入数组中, 等待resolve调用执行</p> <h3 id="参考文献-6"><a href="#参考文献-6" class="header-anchor">#</a> 参考文献</h3> <ol><li>面试宝典V4.0 (2022版)</li> <li><a href="https://juejin.cn/post/7112380113265623047" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7112380113265623047<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题17-请仿写promise-all实现"><a href="#问题17-请仿写promise-all实现" class="header-anchor">#</a> 问题17: 请仿写Promise.all实现</h2> <h3 id="目标-16"><a href="#目标-16" class="header-anchor">#</a> 目标</h3> <ul><li>了解Promise.all内部实现的大体过程</li> <li>在笔试时/面试时可以仿写/说出</li></ul> <h3 id="讲解-17"><a href="#讲解-17" class="header-anchor">#</a> 讲解</h3> <ol><li>代码如下,先读懂, 然后仿写5-10遍</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myAll</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">const</span> resArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 申请空数组, 长度为外面传入Promise数组的个数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 取出每个小Promise对象等待结果</span>
                resArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> result <span class="token comment">// 因为用的i, 所以有块作用域, 保证i的值和p顺序对应</span>
                index<span class="token operator">++</span> <span class="token comment">// 当本次执行后和所有的Promise个数对比, 相等, 就把最后resArr数组返回</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> p<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span>resArr<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">myAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">,</span> p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="小结-17"><a href="#小结-17" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>如果口述最基础的思路:
定义all函数后, 接收外部传入小Promise对象的数组, 并返回一个自定义的大Promise对象完成合并
然后在大Promise对象内, 准备结果数组和完成的计数器index
在大Promise对象内, 继续遍历每个小Promise对象的then和catch等待结果
成功的, 按照i索引放入结果数组里, 并计数器+1判断是否为最后一个, 为最后一个直接用大Promise对象的resolve传结果数组出去
有一个小Promise对象走失败, 直接调用大Promise对象的reject导致外部失败即可</p> <h3 id="参考文献-7"><a href="#参考文献-7" class="header-anchor">#</a> 参考文献</h3> <ol><li>无</li> <li>自己手写</li></ol> <h2 id="问题18-什么是函数式编程"><a href="#问题18-什么是函数式编程" class="header-anchor">#</a> 问题18: 什么是函数式编程?</h2> <h3 id="目标-17"><a href="#目标-17" class="header-anchor">#</a> 目标</h3> <ul><li>了解什么是函数式编程</li> <li>了解函数式编程的优缺点</li></ul> <h3 id="讲解-18"><a href="#讲解-18" class="header-anchor">#</a> 讲解</h3> <ol><li>面向函数编程与面向过程编程, 和面向对象编程都是一种编程规范方式(思想)</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 命令式编程</span>
<span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 函数式方式</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>强调将计算过程分解成可复用的函数，典型例子就是<code>map</code>方法和<code>reduce</code>方法</li> <li>函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用</li> <li>强调函数可以作为实参, 或者作为返回值参与到代码执行的流程中去</li> <li>优点: 可以复用, 可以任意组合, 减低耦合性</li> <li>缺点:</li></ol> <ul><li>资源占用每个函数都要开一个执行上下文(局部作用域)在内存中</li> <li>代码不易于阅读</li></ul> <h3 id="小结-18"><a href="#小结-18" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>函数式编程和面向过程和对象一样是一种新的编程思想, 就是把计算过程分成可复用的函数, 定义好参数, 并在函数内返回结果</p> <h3 id="参考文献-8"><a href="#参考文献-8" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="https://lamphc.github.io/fe-up/#/JavaScript/functional_programming" target="_blank" rel="noopener noreferrer">https://lamphc.github.io/fe-up/#/JavaScript/functional_programming<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904153823592461" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904153823592461<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904061818142728" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904061818142728<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6923758566323159048" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6923758566323159048<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener noreferrer">https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>  (推荐看这个)</li> <li><a href="https://zhuanlan.zhihu.com/p/502056464" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/502056464<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017328525009056" target="_blank" rel="noopener noreferrer">https://www.liaoxuefeng.com/wiki/1016959663602400/1017328525009056<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题19-什么是函数柯里化"><a href="#问题19-什么是函数柯里化" class="header-anchor">#</a> 问题19: 什么是函数柯里化?</h2> <h3 id="目标-18"><a href="#目标-18" class="header-anchor">#</a> 目标</h3> <ul><li>了解函数可里化目的</li> <li>了解如何编写</li></ul> <h3 id="讲解-19"><a href="#讲解-19" class="header-anchor">#</a> 讲解</h3> <ol><li>柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程</li> <li>目的是让纯函数更纯，每次接受一个参数，松散解耦</li> <li>代码体现(基础)</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c
<span class="token punctuation">}</span>

<span class="token comment">// 改装成可里化函数</span>
<span class="token keyword">function</span> <span class="token function">sumX</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sumX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证每个函数只接收一个参数</span>
</code></pre></div><ol start="4"><li>通用可里化(进阶, 较难)</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 但是上面的函数只能算3个数的和, 体现不出函数可里化威力, 改装下</span>
<span class="token keyword">const</span> <span class="token function-variable function">sumY</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">curriedFn</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 函数.length拿到的是形参个数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 返回到myfn()调用处, 被调用继续执行curriedFn方法, 并把参数的值拼接成一个数组继续传入, 注意先执行args.concat拼接数组, 再...展开所有实际值传入</span>
                <span class="token keyword">return</span> <span class="token function">curriedFn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 最后都收集好了, 执行一次这里, 返回4个数的值, 再逐层返回到最外面</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z <span class="token operator">+</span> a<span class="token punctuation">;</span>
<span class="token keyword">const</span> myfn <span class="token operator">=</span> <span class="token function">sumY</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// myfn就是curriedFn函数</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myfn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="小结-19"><a href="#小结-19" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程, 目的是让纯函数更纯，每次接受一个参数，松散解耦</p> <h3 id="参考文献-9"><a href="#参考文献-9" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="https://lamphc.github.io/fe-up/#/JavaScript/functional_programming" target="_blank" rel="noopener noreferrer">https://lamphc.github.io/fe-up/#/JavaScript/functional_programming<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener noreferrer">https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>  (推荐看这个)</li></ol> <h1 id="同步异步相关"><a href="#同步异步相关" class="header-anchor">#</a> 同步异步相关</h1> <h2 id="问题-为什么js是单线程的"><a href="#问题-为什么js是单线程的" class="header-anchor">#</a> 问题: 为什么JS是单线程的?</h2> <h3 id="目标-19"><a href="#目标-19" class="header-anchor">#</a> 目标</h3> <ul><li>理解并说出JS为什么是单线程的?</li></ul> <h3 id="讲解-20"><a href="#讲解-20" class="header-anchor">#</a> 讲解</h3> <ol><li>浏览器<strong>软件</strong>启动, 对应4个<strong>进程</strong></li> <li>渲染进程中有个<strong>JS引擎线程</strong>(一个C++程序), 解析执行JS代码,也称JS主线程</li> <li>而JS为避免复杂性, 诞生就设计成单线程, 同一刻只能执行某行代码</li> <li>例如: 1个线程往DOM上添内容, 另1个线程要删除此DOM节点, 单线程就能避免冲突!</li></ol> <h3 id="小结-20"><a href="#小结-20" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>浏览器内有JS引擎线程, 它某刻只能执行某行代码, 在设计之初就是单线程, 是为了避免2个线程同时操作DOM代码产生冲突, 减低复杂性.</p> <h3 id="参考文献-10"><a href="#参考文献-10" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="http://t.zoukankan.com/ly1368489670-p-12834431.html" target="_blank" rel="noopener noreferrer">http://t.zoukankan.com/ly1368489670-p-12834431.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://t.zoukankan.com/ygunoil-p-15156671.html" target="_blank" rel="noopener noreferrer">http://t.zoukankan.com/ygunoil-p-15156671.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener noreferrer">http://www.ruanyifeng.com/blog/2014/10/event-loop.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>你不知道的JavaScript</li></ol> <h2 id="问题-什么是同步和异步代码"><a href="#问题-什么是同步和异步代码" class="header-anchor">#</a> 问题: 什么是同步和异步代码?</h2> <h3 id="目标-20"><a href="#目标-20" class="header-anchor">#</a> 目标</h3> <ul><li>理解并说出, 同步以及异步代码区别</li></ul> <h3 id="讲解-21"><a href="#讲解-21" class="header-anchor">#</a> 讲解</h3> <ol><li>同步代码: <strong>立即</strong>放入JS引擎(JS主线程)执行, 并<strong>原地等待</strong>结果</li> <li>异步代码: 先放入宿主环境(浏览器/Node), 不必原地等待结果, 并<strong>不阻塞</strong>主线程继续往下执行, 异步结果在<strong>将来执行</strong>(一般都有回调函数)</li> <li>比如异步代码有:</li></ol> <ul><li>setTimeout (一次性定时器)</li> <li>setInterval  (定时器)</li> <li>Ajax/Fetch</li> <li>事件绑定</li> <li>....</li> <li>Promise本身是同步的, 但是then和catch是异步的</li></ul> <ol start="4"><li>代码体现</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>

<span class="token comment">// 打印结果: 1, 3, 2</span>
</code></pre></div><h3 id="小结-21"><a href="#小结-21" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>同步代码立即执行, 原地等待结果后继续下一行
异步代码交给宿主环境执行, 不在原地等待结果, 不阻塞向下执行其他代码</p> <h3 id="参考文献-11"><a href="#参考文献-11" class="header-anchor">#</a> 参考文献</h3> <ol><li>你不知道的JavaScript</li> <li><a href="https://blog.csdn.net/weixin_46022934/article/details/121322193" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_46022934/article/details/121322193<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>mdn: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题-什么是事件循环"><a href="#问题-什么是事件循环" class="header-anchor">#</a> 问题: 什么是事件循环?</h2> <h3 id="目标-21"><a href="#目标-21" class="header-anchor">#</a> 目标</h3> <ul><li>掌握理解和说出, 事件循环概念并帮助自己理解代码执行顺序</li> <li>想考察JS如何执行异步代码的机制</li> <li>如果考什么是任务队列, 也可以回答这个</li></ul> <h3 id="讲解-22"><a href="#讲解-22" class="header-anchor">#</a> 讲解</h3> <blockquote><p>EventLoop是事件循环的英文描述</p></blockquote> <ol><li>事件循环是JS处理执行异步代码的一种线程和内存调度机制</li> <li>JS引擎并不是独立运行的，它运行在宿主环境中</li> <li>JS解析执行到异步代码时, 会交给宿主环境执行并携带一个<strong>回调函数</strong></li> <li>宿主环境执行后, 把回调函数推入到<strong>任务队列</strong>中排队等待</li> <li>等待JS引擎(主线程执行栈)空闲后, 调用<strong>任务队列</strong>中回调函数执行, 再次空间后再调用执行, 循环的过程就叫事件循环</li> <li>代码</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>

<span class="token comment">// 打印结果: 1, 3, 2</span>
</code></pre></div><ol start="7"><li>图示1:
<img src="https://cdn.nlark.com/yuque/0/2022/png/22014993/1657202702725-aedebc2d-d9b5-4c71-a017-b7f2159685cd.png#clientId=u4afc02fb-6a9b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=452&amp;id=ubc9b18f0&amp;name=image.png&amp;originHeight=565&amp;originWidth=1041&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=103091&amp;status=done&amp;style=none&amp;taskId=u6e9df897-e6bd-4493-a327-d7aeb743351&amp;title=&amp;width=832.8" alt="image.png"></li> <li>图示2:
<img src="https://cdn.nlark.com/yuque/0/2022/png/22014993/1657202729348-b9fa99f6-bbec-420d-8fcf-04d8c1b99168.png#clientId=u4afc02fb-6a9b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=411&amp;id=u07b33959&amp;name=image.png&amp;originHeight=710&amp;originWidth=881&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=166102&amp;status=done&amp;style=none&amp;taskId=u5c9a97e0-bc28-4630-942b-0eb28a65ac0&amp;title=&amp;width=509.8000183105469" alt="image.png"></li></ol> <h3 id="小结-22"><a href="#小结-22" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理, 回答时脑子里可以想图之间关系</p></blockquote> <p>事件循环是JS执行异步代码的一种机制, 执行栈遇到异步代码交给宿主环境, 宿主环境执行异步代码后有结果, 把回调函数推入任务队列排队, 等待执行栈空闲往复调用任务队列里回调函数执行的过程就是事件循环</p> <h3 id="参考文献-12"><a href="#参考文献-12" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="http://fanyouf.gitee.io/interview/javascript/event_loop" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/event_loop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener noreferrer">http://www.ruanyifeng.com/blog/2014/10/event-loop.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>你不知道的JavaScript</li> <li><a href="https://lamphc.github.io/fe-up/#/JavaScript/event_loop" target="_blank" rel="noopener noreferrer">https://lamphc.github.io/fe-up/#/JavaScript/event_loop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>面试宝典V4.0 (2022-01)</li> <li>执行栈:所有同步任务都在主线程上执行，形成一个执行栈</li></ol> <h2 id="问题-什么是宏任务和微任务"><a href="#问题-什么是宏任务和微任务" class="header-anchor">#</a> 问题: 什么是宏任务和微任务?</h2> <h3 id="目标-22"><a href="#目标-22" class="header-anchor">#</a> 目标</h3> <ul><li>掌握说出和区别, 宏任务和微任务</li> <li>掌握宏任务队列和微任务队列执行时机</li></ul> <h3 id="讲解-23"><a href="#讲解-23" class="header-anchor">#</a> 讲解</h3> <ol><li><p>JS把异步代码分为宏任务和微任务, 在ES6有了Promise, JS引擎也能发起异步任务了</p></li> <li><p>宏任务: 宿主环境(浏览器/Node)发起的任务叫宏任务<br>
| 任务（代码） | 宏任务 | 环境 |
| --- | --- | --- |
| script | 宏任务 | 浏览器 |
| 事件 | 宏任务 | 浏览器 |
| 网络请求（Ajax/Fetch） | 宏任务 | 浏览器 |
| setTimeout() 一次性定时器/setInterval() 定时器 | 宏任务 | 浏览器 |</p></li> <li><p>微任务: JS引擎发起的任务叫微任务(Promise)</p></li></ol> <blockquote><p>Promise本身同步, then/catch的回调函数是异步的</p></blockquote> <table><thead><tr><th>任务（代码）</th> <th>微任务</th> <th>环境</th></tr></thead> <tbody><tr><td>Promise</td> <td>微任务</td> <td>JS引擎</td></tr></tbody></table> <ol start="4"><li>首先一个JS脚本(script)本身对于浏览器而言就是一个宏任务，也是第一个宏任务.</li> <li>逐行执行其中的代码可能有3种：同步代码、微任务的异步代码（promise等）、宏任务的异步代码(settimeout、setinterval等)</li></ol> <ul><li>遇到同步放入执行栈立即执行</li> <li>遇到微任务代码, Promise内立即执行, then/catch的回调函数放入当前(宏任务范围内的微任务列表中排队)</li> <li>遇到宏任务代码, 交给宿主环境, 并等待执行后, 把回调函数放入任务队列中排队</li></ul> <ol start="6"><li>执行栈执行所有同步代码空闲后, 先清空当前宏任务范围内的微任务列表中回调函数, 再执行下一个宏任务</li> <li>图示1: 宏任务队列和微任务队列关系
<img src="https://cdn.nlark.com/yuque/0/2022/png/22014993/1657202799537-d6c87eb9-7c47-4319-a84d-077f2c336c81.png#clientId=u4afc02fb-6a9b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=497&amp;id=u2e4bc3f0&amp;name=image.png&amp;originHeight=886&amp;originWidth=902&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=136475&amp;status=done&amp;style=none&amp;taskId=u83b92481-b31e-4255-89b6-7e8628a54d0&amp;title=&amp;width=506" alt="image.png"></li> <li>图示2: 宏任务和微任务执行顺序
<img src="https://cdn.nlark.com/yuque/0/2022/png/22014993/1657202825393-e12079ee-ba63-4fa6-9342-c4bda3030592.png#clientId=u4afc02fb-6a9b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=234&amp;id=u611a193f&amp;name=image.png&amp;originHeight=292&amp;originWidth=1021&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=49728&amp;status=done&amp;style=none&amp;taskId=u46301fd2-f966-418e-be94-fbd280b888c&amp;title=&amp;width=816.8" alt="image.png"></li> <li>代码示例: 请按照上面理解后的回答下面打印顺序</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
        <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>


<span class="token comment">// 答案: 13842567</span>
</code></pre></div><h3 id="小结-23"><a href="#小结-23" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>方面1: 区分</p> <ul><li>宏任务: 宿主环境(浏览器/Node)发起的任务叫宏任务</li> <li>微任务: JS引擎发起的任务叫微任务(Promise)</li></ul> <p>方面2: 执行顺序
JS在执行代码的时候, 会遇到同步代码, 微任务代码, 宏任务代码</p> <ul><li>遇到同步按行执行</li> <li>遇到微任务代码也是交给JS引擎执行, 但是回调函数在微任务队列中排队等待</li> <li>遇到宏任务代码, 交给宿主环境(有结果进入任务队列)</li> <li>等待执行栈空闲, 清空微任务队列, 再执行下一个宏任务(回到1)</li></ul> <p>执行顺序, 第一个script宏任务-&gt;所有同步代码-&gt;微任务队列-&gt;下一个宏任务(回到开始继续)</p> <h3 id="参考文献-13"><a href="#参考文献-13" class="header-anchor">#</a> 参考文献</h3> <ol><li>极客时间-&gt;重学前端</li> <li>面试宝典V4.0 (2022-01)</li> <li><a href="http://fanyouf.gitee.io/interview/javascript/event_loop.html#%E4%BA%8C%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/event_loop.html#二、宏任务与微任务<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题-什么是async和await"><a href="#问题-什么是async和await" class="header-anchor">#</a> 问题: 什么是async和await?</h2> <h3 id="目标-23"><a href="#目标-23" class="header-anchor">#</a> 目标</h3> <ul><li>掌握和理解async和await概念</li> <li>掌握并编写async和await的代码</li></ul> <h3 id="讲解-24"><a href="#讲解-24" class="header-anchor">#</a> 讲解</h3> <ol><li>虽然Promise的then链式调用能解决回调地狱, 但是代码不便于阅读</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> pname <span class="token operator">=</span> <span class="token string">''</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">myAjax</span><span class="token punctuation">(</span><span class="token string">'http://ajax-api.itheima.net/api/province'</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    pname <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token comment">// '辽宁省'</span>
    <span class="token keyword">return</span> <span class="token function">myAjax</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://ajax-api.itheima.net/api/city?pname=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cname <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token comment">// '辽阳市'</span>
    <span class="token keyword">return</span> <span class="token function">myAjax</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://ajax-api.itheima.net/api/area?pname=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&amp;cname=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>cname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>ES7提出ES8标准的, async和await关键字来取代then函数, 让代码便于编写和阅读</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">getListFn</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">myAjax</span><span class="token punctuation">(</span><span class="token string">'http://ajax-api.itheima.net/api/province'</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> pname <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token comment">// '辽宁省'</span>
    <span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">myAjax</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://ajax-api.itheima.net/api/city?pname=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> cname <span class="token operator">=</span> res2<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token comment">// '辽阳市'</span>
    <span class="token keyword">const</span> res3 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">myAjax</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://ajax-api.itheima.net/api/area?pname=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&amp;cname=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>cname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 请求是一个个发送的</span>

<span class="token function">getListFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li>await后一般配合Promise对象使用, <strong>等待</strong>成功结果原地</li> <li>await只能用在<strong>async函数内</strong>, 它能暂停代码, 但不会阻塞<strong>外面</strong>主线程执行</li> <li>async函数返回Promise对象, 结果是函数内return的结果</li> <li>如果要捕获await的错误, 可以用try+catch或者.catch链式调用</li></ol> <h3 id="小结-24"><a href="#小结-24" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>async和await关键字取代一般用于取代Promise的then函数, 在async函数内, 使用await把异步流程写成同步流程, 异步终极解决方案
如果还能接着说↓
await只能用在<strong>async函数内</strong>, 它能暂停代码, 但不会阻塞<strong>外面</strong>主线程执行
async函数返回Promise对象, 结果是函数内return的结果
如果要捕获await的错误, 可以用try+catch或者.catch链式调用</p> <h3 id="参考文献-14"><a href="#参考文献-14" class="header-anchor">#</a> 参考文献</h3> <ol><li>极客时间-&gt;重学前端</li> <li>极客时间-&gt;浏览器工作原理与实践</li> <li>面试宝典V4.0 (2022-01)</li> <li>mdn-async</li> <li>es标准: <a href="https://tc39.es/ecma262/#sec-async-function-objects" target="_blank" rel="noopener noreferrer">https://tc39.es/ecma262/#sec-async-function-objects<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener noreferrer">https://www.ruanyifeng.com/blog/2015/05/async.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h1 id="浏览器相关"><a href="#浏览器相关" class="header-anchor">#</a> 浏览器相关</h1> <h2 id="问题-什么是内存泄露"><a href="#问题-什么是内存泄露" class="header-anchor">#</a> 问题: 什么是内存泄露?</h2> <h3 id="目标-24"><a href="#目标-24" class="header-anchor">#</a> 目标</h3> <ul><li>了解什么是内存泄露</li> <li>知道如何避免内存泄露</li></ul> <h3 id="讲解-25"><a href="#讲解-25" class="header-anchor">#</a> 讲解</h3> <ol><li>内存泄漏, 是由于疏忽或错误, 导致不再使用的内存未被释放</li></ol> <ul><li>例如1: 意外的全局变量</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>intro <span class="token operator">=</span> <span class="token string">&quot;我会内存泄露&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果未开启严格模式, 则this指向window对象, 则intro属性变为全局对象里一个属性一直占用内存</span>
</code></pre></div><ul><li>例如2: 定时器或计时器或事件监听, 不销毁会导致内存泄露</li></ul> <blockquote><p>比如在递归函数里用addEventListener给一个标签绑定事件几千次</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 每隔1秒都创建了1个计时器 - 而且内部f计时器从未销毁过</span>
</code></pre></div><ul><li>图示: (蓝色表示分配的内存)
<img src="https://cdn.nlark.com/yuque/0/2022/png/22014993/1657202873317-20620d97-7300-4778-a77d-6908414fa397.png#clientId=u4afc02fb-6a9b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=463&amp;id=u834c2c31&amp;name=image.png&amp;originHeight=579&amp;originWidth=1030&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=85279&amp;status=done&amp;style=none&amp;taskId=u039872a1-4591-4ca5-9423-68f4f0ea828&amp;title=&amp;width=824" alt="image.png"></li> <li>例3: 闭包内, 引用外层函数的变量, 导致外层函数执行后无法被回收, 也会在内存中一直存在</li> <li>例4: 深拷贝对象时, 对象互相引用</li></ul> <blockquote><p>详情可看此视频: <a href="https://www.bilibili.com/video/BV1jv411W76k?p=4&amp;vd_source=91b7751815160bf9e0d92453461c08ba" target="_blank" rel="noopener noreferrer">深拷贝对象互相引用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="小结-25"><a href="#小结-25" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>内存泄漏, 是由于疏忽或错误, 导致不再使用的内存未释放, 看似没什么问题, 但是等占用的内存把软件可用内存堆满时就会产生内存溢出
内存溢出, 导致执行栈空间爆满, 导致JS脚本无法继续执行, 在浏览器报错</p> <h3 id="参考文献-15"><a href="#参考文献-15" class="header-anchor">#</a> 参考文献</h3> <ol><li>面试宝典V4.0 (2022-01)</li> <li><a href="https://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener noreferrer">https://www.ruanyifeng.com/blog/2017/04/memory-leak.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>极客时间-&gt;浏览器工作原理与实践</li> <li><a href="https://blog.csdn.net/zyb18507175502/article/details/124120491" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/zyb18507175502/article/details/124120491<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题-为什么0-1加0-2不等于0-3"><a href="#问题-为什么0-1加0-2不等于0-3" class="header-anchor">#</a> 问题: 为什么0.1加0.2不等于0.3?</h2> <h3 id="目标-25"><a href="#目标-25" class="header-anchor">#</a> 目标</h3> <ul><li>了解计算机是如何运行小数加减的</li></ul> <h3 id="讲解-26"><a href="#讲解-26" class="header-anchor">#</a> 讲解</h3> <ol><li>试着回答这句代码结果</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span>

<span class="token comment">// 答案是: false</span>
</code></pre></div><ol start="2"><li>无论什么语言都运行在计算机上, 而计算机计算数字用的是二进制(因为电脑电路只有高低电平1和0之分)</li> <li>而64位系统计算机中, 用64位二进制表示一个数字最大范围, 于是规定:  1位符号位，11位指数位，52位小数位</li> <li>当把小数转成二进制0和1以后, 会无限循环,但是小数位只能有52位, 下面是多写了几位</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">0.1</span> <span class="token operator">=&gt;</span> <span class="token number">0.00011001100110011001100110011001100110011001100110011010</span><span class="token operator">...</span>（无限循环）
<span class="token number">0.2</span> <span class="token operator">=&gt;</span> <span class="token number">0.001100110011001100110011001100110011001100110011001101</span>（无限循环）

<span class="token comment">// 计算机进行加法运算后</span>
<span class="token number">0.0100110011001100110011001100110011001100110011001100111</span> <span class="token punctuation">(</span>转回<span class="token number">10</span><span class="token literal-property property">进制结果为</span><span class="token operator">:</span> <span class="token number">0.30000000000000004</span><span class="token punctuation">)</span>
</code></pre></div><ol start="5"><li>所以转成二进制计算后再转回来造成了进度误差, 结果不准确</li> <li>正确的比较小数的方式是检查等式左右两边差的绝对值是否小于最小精度</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="小结-26"><a href="#小结-26" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>计算机计算小数时, 需要转成二进制计算, 转换后的数字是无限循环, 但是只能保留52位小数位进度. 计算后在转回10进制标识造成了精度丢失, 正确比较应该用差的绝对值是否小于JS最小精度</p> <h3 id="参考文献-16"><a href="#参考文献-16" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="http://fanyouf.gitee.io/interview/javascript/loss_accuracy.html" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/loss_accuracy.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>你不知道的JavaScript</li> <li>极客时间-重学前端</li> <li>进制转换: <a href="https://tool.oschina.net/hexconvert/" target="_blank" rel="noopener noreferrer">https://tool.oschina.net/hexconvert/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h1 id="优化相关"><a href="#优化相关" class="header-anchor">#</a> 优化相关</h1> <h2 id="问题-什么是防抖"><a href="#问题-什么是防抖" class="header-anchor">#</a> 问题: 什么是防抖?</h2> <h3 id="目标-26"><a href="#目标-26" class="header-anchor">#</a> 目标</h3> <ul><li>能够说出它的概念和使用场景</li></ul> <h3 id="讲解-27"><a href="#讲解-27" class="header-anchor">#</a> 讲解</h3> <ol><li>本质就是降低代码执行的频率, 提升用户的体验</li> <li>n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li> <li>常用在搜索框, 降低搜索触发频率, 只显示用户<strong>最后一次</strong>要搜索的结果</li></ol> <h3 id="小结-27"><a href="#小结-27" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>防抖是为了降低代码执行频率,  n秒后执行逻辑代码, 如果n秒内被触发, 则重新计时, 执行最后一次, 常用在搜索框中</p> <h3 id="参考文献-17"><a href="#参考文献-17" class="header-anchor">#</a> 参考文献</h3> <ol><li>前端面试宝典V4.0--2022.1.pdf</li> <li><a href="http://fanyouf.gitee.io/interview/javascript/debounce_throttle.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/debounce_throttle.html#一、是什么<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904121326108686" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904121326108686<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>旭哥视频: <a href="https://www.bilibili.com/video/BV1y3411r7Pr?spm_id_from=333.999.0.0&amp;vd_source=91b7751815160bf9e0d92453461c08ba" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1y3411r7Pr?spm_id_from=333.999.0.0&amp;vd_source=91b7751815160bf9e0d92453461c08ba<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题-什么是节流"><a href="#问题-什么是节流" class="header-anchor">#</a> 问题: 什么是节流?</h2> <h3 id="目标-27"><a href="#目标-27" class="header-anchor">#</a> 目标</h3> <ul><li>能够说出它的概念和使用场景</li></ul> <h3 id="讲解-28"><a href="#讲解-28" class="header-anchor">#</a> 讲解</h3> <ol><li>本质就是降低代码执行的频率, 提升用户的体验</li> <li>n 秒内只运行一次，若在 n 秒内重复触发，也只执行一次, 或叫间隔时间执行</li> <li>常用在滚动加载更多, 搜索框其实也可以(看需求, 如果我中间也想执行搜索逻辑而不是最后一次)</li></ol> <h3 id="小结-28"><a href="#小结-28" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>节流是为了降低代码执行频率,  n 秒内只运行一次，若在 n 秒内重复触发，也只执行一次,  常用在滚动加载更多</p> <h3 id="参考文献-18"><a href="#参考文献-18" class="header-anchor">#</a> 参考文献</h3> <ol><li>前端面试宝典V4.0--2022.1.pdf</li> <li><a href="http://fanyouf.gitee.io/interview/javascript/debounce_throttle.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/debounce_throttle.html#一、是什么<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904121326108686" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904121326108686<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>旭哥视频: <a href="https://www.bilibili.com/video/BV1y3411r7Pr?spm_id_from=333.999.0.0&amp;vd_source=91b7751815160bf9e0d92453461c08ba" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1y3411r7Pr?spm_id_from=333.999.0.0&amp;vd_source=91b7751815160bf9e0d92453461c08ba<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题-请实现防抖函数封装"><a href="#问题-请实现防抖函数封装" class="header-anchor">#</a> 问题: 请实现防抖函数封装?</h2> <h3 id="目标-28"><a href="#目标-28" class="header-anchor">#</a> 目标</h3> <ul><li>能够写出防抖函数的封装</li></ul> <h3 id="讲解-29"><a href="#讲解-29" class="header-anchor">#</a> 讲解</h3> <ol><li>参考代码如下: 先读懂, 再仿写5-10遍</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 真正事件处理函数, this: 事件触发者(input)</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token comment">// 清空上一个定时器</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 重新创建定时器并重新定时(一定用箭头函数, this得指向事件处理函数的事件源标签)</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 事件触发者, 替换到具体逻辑this值上</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;input&quot;</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="小结-29"><a href="#小结-29" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>可以口述实现流程的思路:
封装函数, 并返回一个真正执行的事件处理函数, 这样做的目的是让外部传入具体逻辑代码函数进来给fn, 然后在事件处理函数中先清除定时器并创建新的, 而定时器到达时, 回调fn执行即可并别忘了把this执行带回去</p> <h3 id="参考文献-19"><a href="#参考文献-19" class="header-anchor">#</a> 参考文献</h3> <ol><li>前端面试宝典V4.0--2022.1.pdf</li> <li><a href="http://fanyouf.gitee.io/interview/javascript/debounce_throttle.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/debounce_throttle.html#一、是什么<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904121326108686" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904121326108686<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>旭哥视频: <a href="https://www.bilibili.com/video/BV1y3411r7Pr?spm_id_from=333.999.0.0&amp;vd_source=91b7751815160bf9e0d92453461c08ba" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1y3411r7Pr?spm_id_from=333.999.0.0&amp;vd_source=91b7751815160bf9e0d92453461c08ba<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题-请实现节流函数封装"><a href="#问题-请实现节流函数封装" class="header-anchor">#</a> 问题: 请实现节流函数封装?</h2> <h3 id="目标-29"><a href="#目标-29" class="header-anchor">#</a> 目标</h3> <ul><li>掌握节流函数的封装</li></ul> <h3 id="讲解-30"><a href="#讲解-30" class="header-anchor">#</a> 讲解</h3> <ol><li>参考代码如下, 先读懂, 再仿写5-10遍</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 真正的事件处理函数 (this: 事件源)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fn<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// fn.t就是给fn对象扩展个自定义属性保存定时器(也可以像防抖一样写在上面2个函数之间)</span>
        fn<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 确保上面函数中this关键字是事件源 (fn()调用, 上面this就变成了window不对了)</span>
            fn<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 置空, 让事件再次触发的时候, 重新创建一个定时器</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;scroll&quot;</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scrollTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="小结-30"><a href="#小结-30" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>可以口述实现流程的思路:
封装函数, 并返回一个真正执行的事件处理函数, 这样做的目的是让外部传入具体逻辑代码函数进来给fn, 然后在事件处理函数中先判断属性有值(证明有个定时器在倒计时)则提前return拦住, 否则进创建, 并在倒计时结束后把属性值置空, 下次事件触发再绑定新的</p> <h3 id="参考文献-20"><a href="#参考文献-20" class="header-anchor">#</a> 参考文献</h3> <ol><li>前端面试宝典V4.0--2022.1.pdf</li> <li><a href="http://fanyouf.gitee.io/interview/javascript/debounce_throttle.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/debounce_throttle.html#一、是什么<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904121326108686" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904121326108686<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>旭哥视频: <a href="https://www.bilibili.com/video/BV1y3411r7Pr?spm_id_from=333.999.0.0&amp;vd_source=91b7751815160bf9e0d92453461c08ba" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1y3411r7Pr?spm_id_from=333.999.0.0&amp;vd_source=91b7751815160bf9e0d92453461c08ba<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h1 id="应用相关"><a href="#应用相关" class="header-anchor">#</a> 应用相关</h1> <h2 id="问题-如何实现上拉加载更多"><a href="#问题-如何实现上拉加载更多" class="header-anchor">#</a> 问题: 如何实现上拉加载更多?</h2> <h3 id="目标-30"><a href="#目标-30" class="header-anchor">#</a> 目标</h3> <ul><li>了解并说出实现上拉加载更多思路</li></ul> <h3 id="讲解-31"><a href="#讲解-31" class="header-anchor">#</a> 讲解</h3> <ol><li>本质: 在滚动网页时, 可滚动范围将要/正好露底时, 加载额外数据的动作就叫上拉加载更多</li> <li>检测浏览器滚动事件, 并在浏览器卷入距离 &gt;= 获取浏览器可滚动高度 - 浏览器可视高度执行加载更多数据代码</li> <li>公式:   scrollTop &gt;= scrollHeight -  clientHeight</li> <li>示例代码</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> clientHeight  <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span> <span class="token comment">//浏览器高度</span>
<span class="token keyword">let</span> scrollHeight <span class="token operator">=</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">;</span>
<span class="token keyword">let</span> scrollTop <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>
 
<span class="token keyword">let</span> distance <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>  <span class="token comment">//距离视窗还用50的时候，开始触发；</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>scrollTop <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>scrollHeight <span class="token operator">-</span> clientHeight <span class="token operator">-</span> distance<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始加载数据&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="小结-31"><a href="#小结-31" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>检测网页滚动事件, 当卷入距离大于滚动高度-视口高度时, 就判定为滚动触底, 执行加载更多数据的代码</p> <h3 id="参考文献-21"><a href="#参考文献-21" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="http://fanyouf.gitee.io/interview/javascript/pull_up_loading_pull_down_refresh.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/pull_up_loading_pull_down_refresh.html#一、前言<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题-如何实现下拉刷新列表"><a href="#问题-如何实现下拉刷新列表" class="header-anchor">#</a> 问题: 如何实现下拉刷新列表?</h2> <h3 id="目标-31"><a href="#目标-31" class="header-anchor">#</a> 目标</h3> <ul><li>了解并说出实现下拉刷新思路</li></ul> <h3 id="讲解-32"><a href="#讲解-32" class="header-anchor">#</a> 讲解</h3> <ol><li>本质: 页面本身置于顶部时，用户下拉时需要触发的动作</li> <li>标签本身不能随着手拖动而变化, 需要用代码来实现</li> <li>监听touchstart事件, 记录用户手指开始坐标</li> <li>监听touchmove事件, 记录用户手指拖拽坐标, 并超过自己设定的阀值后, 修改标签的translateY属性, 让标签位移有个效果(可设置css过渡动画)</li> <li>监听touchend事件, 手指离开后, 直接让元素translateY属性回到0, 并执行刷新列表的代码上</li></ol> <h3 id="小结-32"><a href="#小结-32" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>标签在顶部手往下拉刷新列表数据, 需要借助touchstart记录开始坐标, touchmove记录移动坐标, 算出偏移量, 用translateY属性修改标签位移效果, 在touchend时, 让标签translateY回到0, 并执行刷新列表代码</p> <h3 id="参考文献-22"><a href="#参考文献-22" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="http://fanyouf.gitee.io/interview/javascript/pull_up_loading_pull_down_refresh.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/pull_up_loading_pull_down_refresh.html#一、前言<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="问题-如何实现大文件上传"><a href="#问题-如何实现大文件上传" class="header-anchor">#</a> 问题: 如何实现大文件上传?</h2> <h3 id="目标-32"><a href="#目标-32" class="header-anchor">#</a> 目标</h3> <ul><li>了解大文件上传的过程</li></ul> <h3 id="讲解-33"><a href="#讲解-33" class="header-anchor">#</a> 讲解</h3> <ol><li>可以使用分片上传, 前端获取到任意文件, 使用FileReader来把文件读成base64字符串</li> <li>然后对字符串进行分割, 分多次上传到同一个接口地址, 让后端把多次的内容合并</li></ol> <h3 id="小结-33"><a href="#小结-33" class="header-anchor">#</a> 小结</h3> <blockquote><p>逐字稿, 可以理解着梳理</p></blockquote> <p>把文件读成base64字符串,按照规律截取多个字符串, 分多次请求某个接口, 让后端合并拼接即可</p> <h3 id="参考文献-23"><a href="#参考文献-23" class="header-anchor">#</a> 参考文献</h3> <ol><li><a href="http://fanyouf.gitee.io/interview/javascript/continue_to_upload.html" target="_blank" rel="noopener noreferrer">http://fanyouf.gitee.io/interview/javascript/continue_to_upload.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/learn/handbook/Array.html" class="prev">
          数组方法
        </a></span> <span class="next"><a href="/learn/handbook/vue.html">
          vue面试题
        </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:0;" data-v-ac050c62></ul></main></div> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/learn/assets/js/app.250e2cfc.js" defer></script><script src="/learn/assets/js/3.51ab3639.js" defer></script><script src="/learn/assets/js/1.504525ea.js" defer></script><script src="/learn/assets/js/12.bfc5c243.js" defer></script>
  </body>
</html>
