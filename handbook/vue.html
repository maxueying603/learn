<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue面试题 | 学习文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习文档">
    
    <link rel="preload" href="/learn/assets/css/0.styles.889b6c4e.css" as="style"><link rel="preload" href="/learn/assets/js/app.250e2cfc.js" as="script"><link rel="preload" href="/learn/assets/js/3.51ab3639.js" as="script"><link rel="preload" href="/learn/assets/js/1.504525ea.js" as="script"><link rel="preload" href="/learn/assets/js/13.ba90bc7d.js" as="script"><link rel="prefetch" href="/learn/assets/js/10.a365623c.js"><link rel="prefetch" href="/learn/assets/js/11.d1d61896.js"><link rel="prefetch" href="/learn/assets/js/12.bfc5c243.js"><link rel="prefetch" href="/learn/assets/js/4.f2ad145d.js"><link rel="prefetch" href="/learn/assets/js/5.acb9c427.js"><link rel="prefetch" href="/learn/assets/js/6.bf0398c6.js"><link rel="prefetch" href="/learn/assets/js/7.36bc8eb5.js"><link rel="prefetch" href="/learn/assets/js/8.43b324b6.js"><link rel="prefetch" href="/learn/assets/js/9.278d5231.js">
    <link rel="stylesheet" href="/learn/assets/css/0.styles.889b6c4e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-5bb33761><div data-v-5bb33761><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-5bb33761 data-v-5bb33761><h3 class="title" data-v-59e6cb88>学习文档</h3> <p class="description" data-v-59e6cb88>学习文档</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2022
      </a></span></div></div> <div class="hide" data-v-5bb33761><header class="navbar" data-v-5bb33761><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn/" class="home-link router-link-active"><!----> <span class="site-name">学习文档</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learn/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      mxy的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3998283094559166" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-5bb33761></div> <aside class="sidebar" data-v-5bb33761><div class="personal-info-wrapper" data-v-1fad0c41 data-v-5bb33761><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>4</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/learn/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      mxy的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3998283094559166" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/learn/" class="sidebar-heading clickable router-link-active"><span>欢迎学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn/" aria-current="page" class="sidebar-link">学前必读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/learn/handbook/ConditionalTypes" class="sidebar-heading clickable open"><span>基础学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn/handbook/Array.html" class="sidebar-link">数组方法</a></li><li><a href="/learn/handbook/js.html" class="sidebar-link">Js面试题</a></li><li><a href="/learn/handbook/vue.html" aria-current="page" class="active sidebar-link">vue面试题</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-5bb33761><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2022
      </a></span></div></div> <div data-v-5bb33761><div data-v-5bb33761><main class="page" style="padding-right:0;"><section style="display:;"><div class="page-title"><h1 class="title">vue面试题</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="vue面试题"><a href="#vue面试题" class="header-anchor">#</a> vue面试题</h1> <h2 id="_1-刷新浏览器后-vuex的数据是否存在-如何解决"><a href="#_1-刷新浏览器后-vuex的数据是否存在-如何解决" class="header-anchor">#</a> 1.刷新浏览器后，vuex的数据是否存在？如何解决？</h2> <p>在vue项目中用vuex来做全局的状态管理， 发现当刷新网页后，保存在vuex实例store里的数据会丢失。
<strong>原因</strong>：因为 store 里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。
<strong>解决方法：</strong>
a.使用vuex-along
vuex-along 的实质也是将 vuex 中的数据存放到 localStorage 或者 sessionStroage 中，只不过这个存取过程组件会帮我们完成，我们只需要用vuex的读取数据方式操作就可以了，简单介绍一下 vuex-along 的使用方法。
安装 vuex-along:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>npm install vuex<span class="token operator">-</span>along <span class="token operator">--</span>save
</code></pre></div><p>配置 vuex-along: 在 store/index.js 中最后添加以下代码:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> VueXAlong <span class="token keyword">from</span> <span class="token string">'vuex-along'</span> <span class="token comment">//导入插件</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">//modules: {</span>
        <span class="token comment">//controler  //模块化vuex</span>
    <span class="token comment">//},</span>
    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">VueXAlong</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'store'</span><span class="token punctuation">,</span>     <span class="token comment">//存放在localStroage或者sessionStroage 中的名字</span>
        <span class="token literal-property property">local</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>      <span class="token comment">//是否存放在local中  false 不存放 如果存放按照下面session的配置</span>
        <span class="token literal-property property">session</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token literal-property property">isFilter</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token comment">//如果值不为false 那么可以传递对象 其中 当isFilter设置为true时， list 数组中的值就会被过滤调,这些值不会存放在seesion或者local中</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>b.使用 localStorage 或者 sessionStroage</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//在页面加载时读取sessionStorage里的状态信息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;store&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>
        Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>
          <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">,</span>
          <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;store&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//在页面刷新时将vuex里的信息保存到sessionStorage里</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;beforeunload&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&quot;store&quot;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h2 id="_2-vue中-route和-router有什么区别"><a href="#_2-vue中-route和-router有什么区别" class="header-anchor">#</a> 2.vue中$route和$router有什么区别？</h2> <p><strong>this.$router是 router 实例</strong>。通过 this.$router 访问路由器,相当于获取了整个路由文件，在$router.option.routes中，或查看到当前项目的整个路由结构 具有实例方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 导航守卫</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 必须调用 `next` */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
router<span class="token punctuation">.</span><span class="token function">beforeResolve</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 必须调用 `next` */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 动态导航到新路由</span>
router<span class="token punctuation">.</span>push
router<span class="token punctuation">.</span>replace
router<span class="token punctuation">.</span>go
router<span class="token punctuation">.</span>back
router<span class="token punctuation">.</span>forward
</code></pre></div><p><strong>this.$route当前激活的路由信息对象</strong>。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过可以 watch (监测变化) 它。通过 this.$route 访问的是当前路由，获取和当前路由有关的信息。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token literal-property property">fullPath</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span>  <span class="token comment">// 当前路由完整路径，包含查询参数和 hash 的完整路径</span>
<span class="token literal-property property">hash</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// 当前路由的 hash 值 (锚点)</span>
<span class="token literal-property property">matched</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 包含当前路由的所有嵌套路径片段的路由记录 </span>
<span class="token literal-property property">meta</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 路由文件中自赋值的meta信息</span>
<span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// 路由名称</span>
<span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 一个 key/value 对象，包含了动态片段和全匹配片段就是一个空对象。</span>
<span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span>  <span class="token comment">// 字符串，对应当前路由的路径</span>
<span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 一个 key/value 对象，表示 URL 查询参数。跟随在路径后用'?'带的参数</span>
</code></pre></div><p>$route 是$router的子级<br>
$route相当于$router.curentRoute</p> <h2 id="_3-vue路由中-history和hash两种模式有什么区别"><a href="#_3-vue路由中-history和hash两种模式有什么区别" class="header-anchor">#</a> 3.vue路由中，history和hash两种模式有什么区别？</h2> <h3 id="hash模式"><a href="#hash模式" class="header-anchor">#</a> hash模式：</h3> <p>hash 模式是一种把前端路由的路径用井号 # 拼接在真实 URL 后面的模式。当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 hashchange 事件。
总结一下 hash 模式的优缺点：</p> <ul><li><strong>优点</strong>：浏览器兼容性较好，连 IE8 都支持</li> <li><strong>缺点</strong>：路径在井号 # 的后面，比较丑</li></ul> <h3 id="history模式"><a href="#history模式" class="header-anchor">#</a> history模式：</h3> <p>history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求。
history API 提供了丰富的函数供开发者调用，我们不妨把控制台打开，然后输入下面的语句来观察浏览器地址栏的变化：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'/b'</span><span class="token punctuation">)</span> <span class="token comment">// 替换路由</span>
history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'/a'</span><span class="token punctuation">)</span> <span class="token comment">// 路由压栈</span>
history<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回</span>
history<span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 前进</span>
history<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 后退2次</span>
</code></pre></div><p>上面的代码监听了 popstate 事件，该事件能监听到：</p> <ul><li>用户点击浏览器的前进和后退操作</li> <li>手动调用 history 的 back、forward 和 go 方法</li></ul> <p>监听不到：</p> <ul><li>history 的 pushState 和 replaceState方法</li></ul> <p>这也是为什么上面的 toA 和 toB 函数内部需要手动调用 render 方法的原因。另外，大家可能也注意到 light-server 的命令多了 --historyindex '/history.html' 参数，这是干什么的呢？
浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404 了。上面的参数的意思就是如果后端资源不存在就返回 history.html 的内容。
因此在线上部署基于 history API 的单页面应用的时候，一定要后端配合支持才行，否则会出现大量的 404。以最常用的 Nginx 为例，只需要在配置的 location / 中增加下面一行即可：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>try_files $uri <span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token punctuation">;</span>
</code></pre></div><p>总结一下 history 模式的优缺点：</p> <ul><li><strong>优点</strong>：路径比较正规，没有井号 #</li> <li><strong>缺点</strong>：兼容性不如 hash，且需要服务端支持，否则一刷新页面就404了</li></ul> <h2 id="_4-vue的最大优势是什么"><a href="#_4-vue的最大优势是什么" class="header-anchor">#</a> 4.vue的最大优势是什么？</h2> <p>Vue 作为一款轻量级框架、简单易学、 数据绑定、组件化、数据和结构的分离、虚拟 DOM、运行速度快，并且作者是 中国人尤雨溪，对应的 API 文档对国内开发者优化，作为前端开发人员的首选入 门框架，Vue 有很多优势:</p> <ul><li>Vue.js 可以进行组件化开发，复用性极强，使代码编写量大大减少，读者更加易于理解。</li> <li>Vue.js 最突出的优势在于可以对数据进行双向绑定。</li> <li>相比传统的页面通过超链接实现页面的切换和跳转，Vue 使用路由不会刷新页面。</li> <li>Vue 是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和 dom， 这样大大加快了访问速度和提升用户体验。</li> <li>而且他的第三方 UI 组件库使用起来节省很多开发时间，从而提升开发效率。</li></ul> <h2 id="_5-mvvm-和-mvc-区别是什么-哪些场景适合"><a href="#_5-mvvm-和-mvc-区别是什么-哪些场景适合" class="header-anchor">#</a> 5.mvvm 和 mvc 区别是什么?哪些场景适合?</h2> <p>1)MVVM 基本定义
MVVM 即 Model-View-ViewModel 的简写。即模型-视图-视图模型。模
型(Model)指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型 (ViewModel)是 mvvm 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向: 一是将模型(Model)转化成视图(View)，即将后端传递的数据转化成所看到的页 面。实现的方式是:数据绑定。二是将视图(View)转化成模型(Model)，即将所看 到的页面转化成后端的数据。实现的方式是:DOM 事件监听。这两个方向都实 现的，我们称之为数据的双向绑定。
2) MVC 基本定义
MVC 是 Model-View- Controller 的简写。即模型-视图-控制器。M 和 V
指的意思和 MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑。 使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。MVC 和 MVVM 的区别并不是 VM 完全 取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念， ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller， 其它视图操作业务等还是应该放在 Controller 中实现。也就是说 MVVM 实现的是 业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。
3)使用场景
MVC 和 MVVM 其实区别并不大。都是一种设计思想。主要就是 MVC 中
Controller 演变成 MVVM 中的 viewModel，MVVM 主要解决了 MVC 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
区别:Vue 数据驱动，通过数据来显示视图层而不是节点操作。 场景:数据操 作比较多的场景，需要大量操作 DOM 元素时，采用 MVVM 的开发方式，会更加 便捷，让开发者更多的精力放在数据的变化上，解放繁琐的操作 DOM 元素。</p> <h2 id="_6-vue数据双向绑定的原理是什么"><a href="#_6-vue数据双向绑定的原理是什么" class="header-anchor">#</a> 6.vue数据双向绑定的原理是什么？</h2> <p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给 订阅者，触发相应的监听回调。
第一步:需要 observe 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 setter 和 getter
这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据 变化
第二步:compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲 染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者， 一旦数据有变动，收到通知，更新视图
第三步:Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情 是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个 update()方法
3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。
第四步:MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher
三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模 板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据 变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p> <h2 id="_7-vue组件间是如何进行传值的"><a href="#_7-vue组件间是如何进行传值的" class="header-anchor">#</a> 7.vue组件间是如何进行传值的？</h2> <p>1)父组件向子组件传递数据 。
父组件内设置要传的数据，在父组件中引用的子组件上绑定一个自定义属性 并把 数据 绑定在 自定义属性上，在子组件中添加参数 props 接收即可
2)子组件向父组件传递数据 。
子组件通过 Vue 实例方法$emit 进行触发并且可以携带参数，父组件监听使用@(v-on)进行监听，然后进行方法处理 。
3)非父子组件之间传递数据
---eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。
1、引入第三方 new Vue 定义为 eventBus
2、在组件中 created 中订阅方法 eventBus.$on(&quot;自定义事件名&quot;,methods 中的方 法名)
3、在另一个兄弟组件中的 methods 中写函数，在函数中发布 eventBus 订阅 的方法 eventBus.$emit(&quot;自定义事件名”)
4、在组件的 template 中绑定事件(比如 click)</p> <h2 id="_8-vue生命周期分为几个阶段"><a href="#_8-vue生命周期分为几个阶段" class="header-anchor">#</a> 8.vue生命周期分为几个阶段？</h2> <p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化 数据、编译模板、挂载 Dom→渲染、更新→渲染、卸载等一系列过程，我们称这 是 Vue 的生命周期。					 			
1)beforeCreate
在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前 被调用。
2)created
在实例创建完成后被立即调用。在这一步，实例已完成以下的配置:数据观 测 (data observer)， 属性和方法的运算，watch/event 事件回调。然而，挂载阶段 还没开始，$el 属性目前不可见。
3)beforeMount
在挂载开始之前被调用:相关的 render 函数首次被调用。
4)mounted
el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。
5)beforeUpdate
数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问 现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间 不被调用，因为只有初次渲染会在服务端进行。
6)updated
由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
7)activated
keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。
8)deactivated
keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。
9)beforeDestroy
实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染 期间不被调用。
10)destroyed
Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有
的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间 不被调用。
11)errorCaptured(2.5.0+ 新增)
当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数:错误对 象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p> <h2 id="_9-第一次加载页面会触发哪几个钩子函数"><a href="#_9-第一次加载页面会触发哪几个钩子函数" class="header-anchor">#</a> 9.第一次加载页面会触发哪几个钩子函数？</h2> <p>当页面第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子函数 。</p> <h2 id="_10-请说下封装vue组件的过程。"><a href="#_10-请说下封装vue组件的过程。" class="header-anchor">#</a> 10.请说下封装vue组件的过程。</h2> <p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立 的模块，解决了我们传统项目开发:效率低、难维护、复用性等问题。
1)分析需求:确定业务需求，把页面中可以服用的结构，样式以及功能，单独 抽离成一个文件，实现复用
2)具体步骤:</p> <ol><li>使用 Vue.component 方法注册组件，子组件需要数据，可以在 props 中接 受定义，而子组件修改好数据后，想把数据传递给父组件。可以采用$emit 方法 向外抛数据</li> <li>如果需要给组件传入模板，则定义为插槽 slot</li> <li>如果需要 父组件主动调用子组件的方法 可以在 methods 选项中开放方法</li></ol> <h2 id="_11-vue组件中的data为什么必须是函数"><a href="#_11-vue组件中的data为什么必须是函数" class="header-anchor">#</a> 11.vue组件中的data为什么必须是函数？</h2> <p>1、每个组件都是 Vue 的实例。
2、组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一 个会影响其他。
3、组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有 的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式， 就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。</p> <h2 id="_12-怎么在组件中监听路由参数的变化"><a href="#_12-怎么在组件中监听路由参数的变化" class="header-anchor">#</a> 12.怎么在组件中监听路由参数的变化？</h2> <p>有两种方法可以监听路由参数的变化，但是只能用在包含<!---->的组 件内。
第一种 watch: {
'$route'(to, from) { // 在此处监听 }, },
第二种
beforeRouteUpdate (to, from, next) { //这里监听 },</p> <h2 id="_13-vue中slot的使用方式-以及slot作用域插槽的用法。"><a href="#_13-vue中slot的使用方式-以及slot作用域插槽的用法。" class="header-anchor">#</a> 13.vue中slot的使用方式，以及slot作用域插槽的用法。</h2> <p>使用方式:当组件当做标签进行使用的时候，用 slot 可以用来接受组件标签 包裹的内容，
当给 solt 标签添加 name 属性的 时候，可以调换响应的位置
插槽作用域:作用域插槽其实就是带数据的插槽，父组件接收来自子组件的 slot 标签上通过 v-bind 绑定进而传递过来的数 据，父组件通过 scope 来进行接受 子组件传递过来的数据。</p> <h2 id="_14-vue该如何实现组件缓存"><a href="#_14-vue该如何实现组件缓存" class="header-anchor">#</a> 14.vue该如何实现组件缓存？</h2> <p>在面向组件化开发中，我们会把整个项目拆分为很多业务组件，然后按照 合理的方式组织起来，那么自然会存在组件之前切换的问题，Vue 中有个动态组 件的概念，它能够帮助开发者更好的实现组件之间的切换，但是在面对需求频繁 的变化，去要切换组件时，动态组件在切换的过程中，组件的实例都是重新创建 的，而我们需要保留组件的状态，为了解决这个问题，需要使用到 Vue 中内置组 件<!----></p> <h2 id="_15-vue常用的修饰符有哪些"><a href="#_15-vue常用的修饰符有哪些" class="header-anchor">#</a> 15.vue常用的修饰符有哪些？</h2> <p>.prevent: 提交事件不再重载页面;.stop: 阻止单击事件冒泡;.self: 当事件发 生在该元素本身而不是子元素的时候会触发;.capture: 事件侦听，事件发生的时 候会调用 。</p> <h2 id="_16-vue常用的指令有哪些-说说他们的作用。"><a href="#_16-vue常用的指令有哪些-说说他们的作用。" class="header-anchor">#</a> 16.vue常用的指令有哪些，说说他们的作用。</h2> <ol><li>v-model 多用于表单元素实现双向数据绑定(同 angular 中的 ng-model)</li> <li>v-for 格式: v-for=&quot;字段名 in(of) 数组 json&quot; 循环数组或 json(同 angular 中的 ng-repeat),需 要注意从 Vue2 开始取消了$index</li> <li>v-show 显示内容 (同 angular 中的 ng-show)</li> <li>v-hide 隐藏内容(同 angular 中的 ng-hide)</li> <li>v-if 显示与隐藏 (dom 元素的删除添加 同 angular 中的 ng-if 默认值为 false)</li> <li>v-else-if 必须和 v-if 连用</li> <li>v-else 必须和 v-if 连用 不能单独使用 否则报错 模板编译错误</li> <li>v-bind 动态绑定 作用: 及时对页面的数据进行更改</li> <li>v-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在 methods 里面</li> <li>v-text 解析文本</li> <li>v-html 解析 html 标签</li> <li>v-bind:class 三种绑定方法 ：、对象型 '{red:isred}' 2、三元型 'isred?&quot;red&quot;:&quot;blue&quot;' 3、数组型</li></ol> <p>'[{red:&quot;isred&quot;},{blue:&quot;isblue&quot;}]'。
13.v-once 进入页面时 只渲染一次 不在进行渲染
14.v-cloak 防止闪烁
15.v-pre 把标签内部的元素原位输出</p> <h2 id="_17-v-show和v-if指令的共同点和不同点"><a href="#_17-v-show和v-if指令的共同点和不同点" class="header-anchor">#</a> 17.v-show和v-if指令的共同点和不同点？</h2> <p>1)相同点:
v-show 和 v-if 都能控制元素的显示和隐藏。
2)不同点:
实现本质方法不同
v-show 本质就是通过设置 css 中的 display 设置为 none，控制隐藏
v-if 是动态的向 DOM 树内添加或者删除 DOM 元素
3)编译的区别
v-show 其实就是在控制 css
v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件
4)编译的条件
v-show 都会编译，初始值为 false，只是将 display 设为 none，但它也编译了
v-if 初始值为 false，就不会编译了
5)性能比较
v-show 只编译一次，后面其实就是控制 css，而 v-if 不停的销毁和创建，故 v-show 性能更好一点。
注意点:因为 v-show 实际是操作 display:&quot; &quot;或者 none，当 css 本身有 display:none 时，v-show 无法让显示
总结(适用场景):如果要频繁切换某节点时，使用 v-show(无论 true 或者 false 初始都会进行渲染，此后通过 css 来控制显示隐藏，因此切换开销比较小，初始 开销较大)，如果不需要频繁切换某节点时，使用 v-if(因为懒加载，初始为 false 时，不会渲染，但是因为它是通过添加和删除 dom 元素来控制显示和隐藏的， 因此初始渲染开销较小，切换开销比较大) 。</p> <h2 id="_18-为什么避免v-if和v-for一起用"><a href="#_18-为什么避免v-if和v-for一起用" class="header-anchor">#</a> 18.为什么避免v-if和v-for一起用？</h2> <p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，通过 v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次， 且不会在 v-if 为否的时候运算 v-for。</p> <h2 id="_19-watch、methods、computed的区别"><a href="#_19-watch、methods、computed的区别" class="header-anchor">#</a> 19.watch、methods、computed的区别？</h2> <p>1)基本说明
1.computed:
计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文 自动地绑定为 Vue 实例。
2.methods:
methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。
3.watch:
观察和响应 Vue 实例上的数据变动，一个对象，键是需要观察的表达式， 值是对应回调函数。值也可以是方法名，或者包含选项的对象，Vue 实例将会在 实例化时调用 $watch()，遍历 watch 对象的每一个属性。
2)三者的加载顺序</p> <ol><li>computed 是在 HTML DOM 加载后马上执行的，如赋值;(属性将被混入 到 Vue 实例)</li> <li>methods 则必须要有一定的触发条件才能执行，如点击事件</li> <li>watch 呢?它用于观察 Vue 实例上的数据变动。</li></ol> <p>3)默认加载的时候
先 computed 再 watch，不执行 methods;
4)触发某一事件后
先 computed 再 methods 再到 watch
computed 属性 vs method 方法
computed 计算属性是基于它们的依赖进行缓存的。
5)总结
计算属性 computed 只有在它的相关依赖发生改变时才会重新求值，当有一个性能开销比较大的的计算属性 A ，它需要遍历一个极大的数组和做大量的计算， 然后我们可能有其他的计算属性依赖于 A ，这时候，我们就需要缓存，每次确实需要重新加载，不需要缓存时用 methods。</p> <h2 id="_20-怎么在watch监听开始之后立即被调用"><a href="#_20-怎么在watch监听开始之后立即被调用" class="header-anchor">#</a> 20.怎么在watch监听开始之后立即被调用？</h2> <p>在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调。</p> <h2 id="_21-computed中的属性名和data中的属性名可以同名吗"><a href="#_21-computed中的属性名和data中的属性名可以同名吗" class="header-anchor">#</a> 21.computed中的属性名和data中的属性名可以同名吗？</h2> <p>不能同名，因为不管是 computed 属性名还是 data 数据名还是 props 数据名都 会被挂载在 vm 实例上，因此这三个都不能同名。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">.</span>$data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The computed property &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is already defined in data.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span> 
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props <span class="token operator">&amp;&amp;</span> key <span class="token keyword">in</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The computed property &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is already defined as a prop.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_22-什么是vue的计算属性"><a href="#_22-什么是vue的计算属性" class="header-anchor">#</a> 22.什么是vue的计算属性？</h2> <p>在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂 处理，且可能多次使用的情况下，尽量采取计算属性的方式，好处:使得数据处 理结构清晰;</p> <ol><li>依赖于数据，数据更新，处理结果自动更新;</li> <li>计算属性内部 this 指向 vm 实例;</li> <li>在 template 调用时，直接写计算属性名即可;</li> <li>常用的是 getter 方法，获取数据，也可以使用 set 方法改变数据;</li> <li>相较于 methods，不管依赖的数据变不变，methods 都会重新计算，但是依赖数据不变的时候，computed 从缓存中获取，不会重新计算。</li></ol> <h2 id="_23-vue中key值的作用是什么"><a href="#_23-vue中key值的作用是什么" class="header-anchor">#</a> 23.	vue中key值的作用是什么？</h2> <p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用” 策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的 顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过 的每个元素。key 的作用主要是为了高效的更新虚拟 DOM。</p> <h2 id="_24-vuex的5个核心属性是什么"><a href="#_24-vuex的5个核心属性是什么" class="header-anchor">#</a> 24.vuex的5个核心属性是什么？</h2> <p>分别是 State、 Getters、Mutations 、Actions、 Module
** 1)state **
state 为单一状态树，在 state 中需要定义我们所需要管理的数组、对象、字符 串等等，只有在这里定义了，在 Vue.js 的组件中才能获取你定义的这个对象的状 态。</p> <ul><li>注意：store中的state必须放在vue的computed里去使用，不要放在data里。</li></ul> <p>**2)getters **
getter 有点类似 Vue.js 的计算属性，
当我们需要从 store 的 state 中派生出一些状态，那么我们就需要使用 getters，getters 会接收 state 作为第一个参数，而且 getter 的返回值会根据它的依赖被缓存起来，只有 getters 中的依赖值(state中的某个需 要派生状态的值)发生改变的时候才会被重新计算。
<strong>3)mutations</strong>
更改 store 中 state 状态的唯一方法就是提交 mutations，就很类似事件。
每个mutations 都有一个字符串类型的事件类型和一个回调函数，我们需要改变 state 的值就要在回调函数中改变。我们要执行这个回调函数，那么我们需要执行一个相应的调用方法:store.commit。
<strong>4)actions</strong>
actions 可以提交 mutations，在 actions 中可以执行 store.commit，而且 actions 中可以有任何的异步操作。之后再提交给mutations改变state
在页面中如果我们要调用这个 actions，则需要执行 store.dispatch
通过mapActions辅助函数可以生成methods中函数</p> <p>**5)modules **
modules 其实只是解决了当 state 中很复杂臃肿的时候，modules 可以将 store 分割成模块，每个模块中拥有自己的 state、mutations、actions 和 getters</p> <h2 id="_25-vuex的出现解决了什么问题"><a href="#_25-vuex的出现解决了什么问题" class="header-anchor">#</a> 25.vuex的出现解决了什么问题？</h2> <p>主要解决了以下两个问题:
1, 多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐， 并且对于兄弟组件间的状态传递无能为力。
2, 来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者 通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致 无法维护的代码。</p> <h2 id="_26-简述vuex的数据传递流程。"><a href="#_26-简述vuex的数据传递流程。" class="header-anchor">#</a> 26.简述vuex的数据传递流程。</h2> <p>当组件进行数据修改的时候我们需要调用 dispatch 来触发 actions 里面的方法。
actions 里面的每个方法中都会 有一个 commit 方法，当方法执行的时候会通过 commit 来触发 mutations 里面的方法进行数据的修改。mutations 里面的每个函数 都会有一个 state 参数，这样就可以在mutations 里面进行 state 的数据修改 ，当 数据修改完毕后，会传导给页面。页面的数据也会发生改变 。</p> <h2 id="_27-vuex的mutation和action之间的区别是什么"><a href="#_27-vuex的mutation和action之间的区别是什么" class="header-anchor">#</a> 27.vuex的mutation和action之间的区别是什么？</h2> <p>1)流程顺序
“相应视图—&gt;修改 State”拆分成两部分，视图触发 Action，Action 再触发 Mutation。
2)角色定位
基于流程顺序，二者扮演不同的角色。
Mutation:专注于修改 State，理论上是修改 State 的唯一途径。 Action:业务代码、异步请求。
3)限制
角色不同，二者有不同的限制。
Mutation:必须同步执行。
Action:可以异步，但不能直接操作 State。</p> <h2 id="_28-vue-router是干什么的-原理是什么"><a href="#_28-vue-router是干什么的-原理是什么" class="header-anchor">#</a> 28.vue-router是干什么的，原理是什么？</h2> <p>Vue-Router 是 Vue.js 官方的路由插件，它和 Vue.js 是深度集成的，适合用于 构建单页面应用。Vue 的单页面应用是基于路由和组件的，路由用于设定访问路 径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切 换和跳转的。在 Vue-Router 单页面应用中，则是路径之间的切换，也就是组件 的切换。路由模块的本质 就是建立起 url 和页面之间的映射关系。 “更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境 中这一功能的实现主要有两种方式:
利用 URL 中的 hash(“#”)；
利用 History interface 在 HTML5 中新增的方法 。</p> <h2 id="_29-路由间是怎么跳转的-有哪些方式"><a href="#_29-路由间是怎么跳转的-有哪些方式" class="header-anchor">#</a> 29.路由间是怎么跳转的，有哪些方式？</h2> <p>1、<a href="/learn/handbook/需要跳转到页面的路径"> 2、this.$router.push()跳转到指定的 url，并在 history 中添加记录，点击回退返回到上一个页面。
3、this.$router.replace()跳转到指定的 url，但是 history 中不会添加记录，点击 回退到上上个页面。
4、this.$touter.go(n)向前或者后跳转 n 个页面，n 可以是正数也可以是负数 。</a></p> <h2 id="_30-vue-router有哪几种守卫"><a href="#_30-vue-router有哪几种守卫" class="header-anchor">#</a> 30.vue-router有哪几种守卫？</h2> <p>路由守卫为:
全局守卫:beforeEach
后置守卫:afterEach
全局解析守卫:beforeResolve
路由独享守卫:beforeEnter</p> <h2 id="_31-路由传值的方式有哪几种"><a href="#_31-路由传值的方式有哪几种" class="header-anchor">#</a> 31.路由传值的方式有哪几种？</h2> <p>Vue-Router 传参可以分为两大类，分别是编程式的导航 router.push 和声明式的 导航
1)router.push
字符串:直接传递路由地址，但是不能传递参数 this.$router.push(&quot;home&quot;)
对象:
命名路由 这种方式传递参数，目标页面刷新会报错
<code>this.$router.push({name:&quot;news&quot;,params:{userId:123})</code>
查询参数 和 name 配对的式 params，和 path 配对的是 query
<code>this.$router.push({path:&quot;/news',query:{uersId:123})</code>
接收参数 this.$route.query
2)声明式导航
字符串 &lt;router-link to:&quot;news&quot;&gt;
命名路由 &lt;router-link :to:&quot;{name:'news',params:{userid:1111}}&quot;&gt;
查询参 数 <a href="/learn/news?userId=1111"></a></p> <h2 id="_32-怎么定义vue-router的动态路由-怎么获取传过来的动态参数"><a href="#_32-怎么定义vue-router的动态路由-怎么获取传过来的动态参数" class="header-anchor">#</a> 32.怎么定义vue-router的动态路由，怎么获取传过来的动态参数？</h2> <p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如， 我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲 染。那么，我们可以在 Vue-Router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果。
动态路径参数，使用“冒号”开头，一个路径参数，使用冒号标记，当匹配 到一个路由时，参数会被设置到 this.$router.params 中，并且可以在每个组件中使 用。
现在我们知道了可以通过动态路由传参，在路由中设置了，多段路径参数后， 对应的值分别都会设置到$router.query 和$router.params 中 。</p> <h2 id="_33-query和params间的区别是什么"><a href="#_33-query和params间的区别是什么" class="header-anchor">#</a> 33.query和params间的区别是什么？</h2> <p>1、query 要用 path 来引入，params 要用 name 来引入。
2、接收参数时，分别是 this.$route.query.name 和 this.$route.params.name(注意:是$route 而不是$router) 。</p> <h2 id="_34-vue怎么实现跨域"><a href="#_34-vue怎么实现跨域" class="header-anchor">#</a> 34.vue怎么实现跨域？</h2> <p>1)什么是跨域
跨域指浏览器不允许当前页面的所在的源去请求另一个源的数据。源指 协议，端口，域名。只要这个 3 个中有一个不同就是跨域。
2)使用 Vue-cli 脚手架搭建项目时 proxyTable 解决跨域问题 。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token literal-property property">proxyTable</span><span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token string-property property">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">//使用&quot;/api&quot;来代替&quot;http://f.apiplus.c&quot; target: 'http://f.apiplus.cn', //源地址changeOrigin: true, //改变源 pathRewrite: {</span>
<span class="token string-property property">'^/api'</span><span class="token operator">:</span> <span class="token string">'http://f.apiplus.cn'</span> <span class="token comment">//路径重写</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3)使用 CORS(跨域资源共享)
1、前端设置:
前端 Vue 设置 axios 允许跨域携带 cookie(默认是不带 cookie) axios.defaults.withCredentials = true;
2、后端设置:</p> <ol><li>跨域请求后的响应头中需要设置:</li> <li>Access-Control-Allow-Origin 为发起请求的主机地址。</li> <li>Access-Control-Allow-Credentials，当它被设置为 true 时，允许跨域带cookie，但此时 Access-Control- Allow-Origin 不能为通配符*。</li> <li>Access-Control-Allow-Headers，设置跨域请求允许的请求头。</li> <li>Access-Control-Allow-Methods，设置跨域请求允许的请求方式。</li></ol> <h2 id="_35-说说你对spa单页面的理解。"><a href="#_35-说说你对spa单页面的理解。" class="header-anchor">#</a> 35.说说你对SPA单页面的理解。</h2> <p>单页 Web 应用 (single-page application 简称为 SPA) 是一种特殊的 Web 应用。它将所有的活动局限于一个 Web 页面中，仅在该 Web 页面初始化时加载 相应的 HTML、JavaScript 和 CSS。一旦页面加载完成了，SPA 不会因为用户的 操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换  	HTML 的内容，从而实现 UI 与用户的交互。由于避免了页面的重新加载，SPA 可 以提供较为流畅的用户体验。得益于 ajax，我们可以实现无跳转刷新，又多亏了 浏览器的 histroy 机制，我们用 hash 的变化从而可以实现推动界面变化。从而模 拟元素客户端的单页面切换效果:
SPA 被人追捧是有道理的，但是它也有不足之处。当然任何东西都有两面性， 以下是卤煮总结的一些目前 SPA 的优缺点:
1)优点:</p> <ol><li>无刷新界面，给用户体验原生的应用感觉</li> <li>节省原生(android 和 ios)app 开发成本</li> <li>提高发布效率，无需每次安装更新包。这个对于 ios 开发人员来说印象尤其 深吧。</li> <li>容易借助其他知名平台更有利于营销和推广</li> <li>符合 web2.0 的趋势</li></ol> <p>2)缺点:
1、效果和性能确实和原生的有较大差距
2、各个浏览器的版本兼容性不一样
3、业务随着代码量增加而增加，不利于首屏优化
4、某些平台对 hash 有偏见，有些甚至不支持 pushstate
5、不利于搜索引擎抓取</p> <h2 id="_36-怎么理解vue的单向数据流"><a href="#_36-怎么理解vue的单向数据流" class="header-anchor">#</a> 36.怎么理解vue的单向数据流？</h2> <p>数据从父级组件传递给子组件，只能单向绑定。 子组件内部不能直接修改从父级传递过来的数据。
所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定:父级 prop 的更新会向下流动到子组件中，但是反过来则不行。 这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流 向难以理解。
额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。
这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。
子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p> <h2 id="_37-vue中怎么重置data"><a href="#_37-vue中怎么重置data" class="header-anchor">#</a> 37.vue中怎么重置data？</h2> <p>要初始化 data 中的数据，可以使用 Object.assign()方法，实现重置 data 中的 数据，以下就是对该方法的详细介绍，以及如何使用该方法，重置 data 中的数 据 。
1)Object.assign()方法基本定义
Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
用法: Object.assign(target, ...sources)，第一个参数是目标对象，第二个参数是源 对象，就是将源对象属性复制到目标对象，返回目标对象 。
2)具体使用方式
使用 Object.assign()，vm.$data 可以获取当前状态下的 data，
vm.$options.data(this)可以获取到组件初始化状态下的 data，复制 Object.assign(this.$data, this.$options.data(this)) // 注意加 this，不然取不到 data() { a: this.methodA } 中的 this.methodA。</p> <h2 id="_38-vue中的nexttick的原理是什么"><a href="#_38-vue中的nexttick的原理是什么" class="header-anchor">#</a> 38.vue中的nextTick的原理是什么？</h2> <ol><li>为什么需要 nextTick ，Vue 是异步修改 DOM 的并且不鼓励开发者直接 接触 DOM，但有时候业务需要必须对数据更改--刷新后的 DOM 做相应的处理， 这时候就可以使用 Vue.nextTick(callback)这个 api 了。</li> <li>理解原理前的准备 首先需要知道事件循环中宏任务和微任务这两个概念, 常见的宏任务有 script, setTimeout, setInterval, setImmediate, I/O, UI rendering 常 见的微任务有 process.nextTick(Nodejs),Promise.then(), MutationObserver;</li> <li>理解 nextTick 的原理正是 Vue 通过异步队列控制 DOM 更新和 nextTick 回调函数先后执行的方式。如果大家看过这部分的源码，会发现其中做 了很多 isNative()的判断，因为这里还存在兼容性优雅降级的问题。可见 Vue 开 发团队的深思熟虑，对性能的良苦用心。</li></ol> <h2 id="_39-vue实例挂载的过程。"><a href="#_39-vue实例挂载的过程。" class="header-anchor">#</a> 39. 	vue实例挂载的过程。</h2> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/21986664/1656422046725-47e77557-709f-4541-b388-df6b5790cbf4.png#clientId=u7ad4c13a-dd78-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=175&amp;id=u42c79c88&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=349&amp;originWidth=655&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26038&amp;status=done&amp;style=none&amp;taskId=u4693fcbf-9385-4fb1-bed2-3978deb258f&amp;title=&amp;width=327.5" alt="image.png">
一、思考
我们都听过知其然知其所以然这句话
那么不知道大家是否思考过new Vue()这个过程中究竟做了些什么？
过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等</p> <h3 id="一、分析"><a href="#一、分析" class="header-anchor">#</a> #一、分析</h3> <p>首先找到vue的构造函数
源码位置：src\core\instance\index.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Vue</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
<span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Vue</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'Vue is a constructor and should be called with the new keyword'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>options是用户传递过来的配置项，如data、methods等常用的方法
vue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">initMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 定义 _init</span>
<span class="token function">stateMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定义 $set $get $delete $watch 等</span>
<span class="token function">eventsMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 定义事件  $on  $once $off $emit</span>
<span class="token function">lifecycleMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 定义 _update  $forceUpdate  $destroy</span>
<span class="token function">renderMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 定义 _render 返回虚拟dom</span>
</code></pre></div><p>首先可以看initMixin方法，发现该方法在Vue原型上定义了_init方法
源码位置：src\core\instance\init.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">const</span> <span class="token literal-property property">vm</span><span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
<span class="token comment">// a uid</span>
vm<span class="token punctuation">.</span>_uid <span class="token operator">=</span> uid<span class="token operator">++</span>
<span class="token keyword">let</span> startTag<span class="token punctuation">,</span> endTag
<span class="token operator">/</span> istanbul ignore <span class="token keyword">if</span> <span class="token operator">/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
startTag <span class="token operator">=</span> vue<span class="token operator">-</span>perf<span class="token operator">-</span>start<span class="token operator">:</span>$<span class="token punctuation">{</span>vm<span class="token punctuation">.</span>_uid<span class="token punctuation">}</span>
endTag <span class="token operator">=</span> vue<span class="token operator">-</span>perf<span class="token operator">-</span>end<span class="token operator">:</span>$<span class="token punctuation">{</span>vm<span class="token punctuation">.</span>_uid<span class="token punctuation">}</span>
<span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// a flag to avoid this being observed</span>
vm<span class="token punctuation">.</span>_isVue <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token comment">// merge options</span>
<span class="token comment">// 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>_isComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// optimize internal component instantiation</span>
  <span class="token comment">// since dynamic options merging is pretty slow, and none of the</span>
  <span class="token comment">// internal component options needs special treatment.</span>
  <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 合并vue属性</span>
  vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
    <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">,</span>
    options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    vm
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">/* istanbul ignore else */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化proxy拦截器</span>
  <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm
<span class="token punctuation">}</span>
<span class="token comment">// expose real self</span>
vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> vm
<span class="token comment">// 初始化组件生命周期标志位</span>
<span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token comment">// 初始化组件事件侦听</span>
<span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token comment">// 初始化渲染方法</span>
<span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
<span class="token comment">// 初始化依赖注入内容，在初始化data、props之前</span>
<span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve injections before data/props</span>
<span class="token comment">// 初始化props/data/method/watch/methods</span>
<span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve provide after data/props</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>

<span class="token comment">/* istanbul ignore if */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token function">formatComponentName</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span>
  <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> init</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 挂载元素</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><p>仔细阅读上面的代码，我们得到以下结论：
在调用beforeCreate之前，数据初始化并未完成，像data、props这些属性无法访问到；
到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此无法访问到dom元素；
挂载方法是调用vm.$mount方法。
initState方法是完成props/data/method/watch/methods的初始化
源码位置：src\core\instance\state.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 初始化组件的watcher列表</span>
vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
<span class="token comment">// 初始化props</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
<span class="token comment">// 初始化methods方法</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 初始化data</span>
<span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们和这里主要看初始化data的方法为initData，它与initState在同一文件上</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">initData</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data
  <span class="token comment">// 获取到组件上的data</span>
  data <span class="token operator">=</span> vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">'function'</span>
    <span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'data functions should return an object:\n'</span> <span class="token operator">+</span>
      <span class="token string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// proxy data on instance</span>
  <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props
<span class="token keyword">const</span> methods <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>methods
  <span class="token keyword">let</span> i <span class="token operator">=</span> keys<span class="token punctuation">.</span>length
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 属性名不能与方法名重复</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>methods<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Method &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; has already been defined as a data property., vm ) } } // 属性名不能与state名称重复 if (props &amp;&amp; hasOwn(props, key)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn(The data property &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is already declared as a prop. +Use prop default value instead., vm ) } else if (!isReserved(key)) { // 验证key值的合法性 // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据 proxy(vm,_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// observe data</span>
<span class="token comment">// 响应式监听data是数据的变化</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token operator">/</span> asRootData <span class="token operator">/</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>仔细阅读上面的代码，我们可以得到以下结论：
初始化顺序：props、methods、data
data定义的时候可选择函数形式或者对象形式（组件只能为函数形式）
关于数据响应式在这就不展开详细说明
上文提到挂载方法是调用vm.$mount方法
源码位置：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
<span class="token parameter">el<span class="token operator">?</span><span class="token operator">:</span> string <span class="token operator">|</span> Element<span class="token punctuation">,</span>
hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
<span class="token comment">// 获取或查询元素</span>
el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>

<span class="token operator">/</span> istanbul ignore <span class="token keyword">if</span> <span class="token operator">/</span>
<span class="token comment">// vue 不允许直接挂载到body或页面文档上</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>el <span class="token operator">===</span> document<span class="token punctuation">.</span>body <span class="token operator">||</span> el <span class="token operator">===</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
Do not mount Vue to <span class="token operator">&lt;</span>html<span class="token operator">&gt;</span> or <span class="token operator">&lt;</span>body<span class="token operator">&gt;</span> <span class="token operator">-</span> mount to normal elements instead<span class="token punctuation">.</span>
<span class="token punctuation">)</span>
<span class="token keyword">return</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options
<span class="token comment">// resolve template/el and convert to render function</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">let</span> template <span class="token operator">=</span> options<span class="token punctuation">.</span>template
<span class="token comment">// 存在template模板，解析vue模板文件</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> template <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'#'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
template <span class="token operator">=</span> <span class="token function">idToTemplate</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span>
<span class="token operator">/</span> istanbul ignore <span class="token keyword">if</span> <span class="token operator">/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>template<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">warn</span><span class="token punctuation">(</span>
Template element not found or is empty<span class="token operator">:</span> $<span class="token punctuation">{</span>options<span class="token punctuation">.</span>template<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token keyword">this</span>
<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">.</span>nodeType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
template <span class="token operator">=</span> template<span class="token punctuation">.</span>innerHTML
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'invalid template option:'</span> <span class="token operator">+</span> template<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 通过选择器获取元素内容</span>
template <span class="token operator">=</span> <span class="token function">getOuterHTML</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex"> istanbul ignore if </span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'compile'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
*  1.将temmplate解析ast tree
*  2.将ast tree转换成render语法字符串
*  3.生成render方法
*/</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> staticRenderFns <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> <span class="token punctuation">{</span>
<span class="token literal-property property">outputSourceRange</span><span class="token operator">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">,</span>
shouldDecodeNewlines<span class="token punctuation">,</span>
shouldDecodeNewlinesForHref<span class="token punctuation">,</span>
<span class="token literal-property property">delimiters</span><span class="token operator">:</span> options<span class="token punctuation">.</span>delimiters<span class="token punctuation">,</span>
<span class="token literal-property property">comments</span><span class="token operator">:</span> options<span class="token punctuation">.</span>comments
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
options<span class="token punctuation">.</span>render <span class="token operator">=</span> render
options<span class="token punctuation">.</span>staticRenderFns <span class="token operator">=</span> staticRenderFns
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/* istanbul ignore if */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'compile end'</span><span class="token punctuation">)</span>
  <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> compile</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token string">'compile'</span><span class="token punctuation">,</span> <span class="token string">'compile end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token function">mount</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><p>阅读上面代码，我们能得到以下结论：
不要将根元素放到body或者html上
可以在对象中定义template/render或者直接使用template、el表示元素选择器
最终都会解析成render函数，调用compileToFunctions，会将template解析成render函数
对template的解析步骤大致分为以下几步：
将html文档片段解析成ast描述符
将ast描述符解析成字符串
生成render函数
生成render函数，挂载到vm上后，会再次调用mount方法
源码位置：src\platforms\web\runtime\index.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// public mount method</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
<span class="token parameter">el<span class="token operator">?</span><span class="token operator">:</span> string <span class="token operator">|</span> Element<span class="token punctuation">,</span>
hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> inBrowser <span class="token operator">?</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">undefined</span>
<span class="token comment">// 渲染组件</span>
<span class="token keyword">return</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
调用mountComponent渲染组件

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span> <span class="token punctuation">(</span>
<span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component<span class="token punctuation">,</span>
<span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token operator">?</span>Element<span class="token punctuation">,</span>
hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el
  <span class="token comment">// 如果没有获取解析的render函数，则会抛出警告</span>
  <span class="token comment">// render是解析模板文件生成的</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render <span class="token operator">=</span> createEmptyVNode
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* istanbul ignore if */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>template <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>template<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">'#'</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el <span class="token operator">||</span> el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">warn</span><span class="token punctuation">(</span>
<span class="token string">'You are using the runtime-only build of Vue where the template '</span> <span class="token operator">+</span>
<span class="token string">'compiler is not available. Either pre-compile the templates into '</span> <span class="token operator">+</span>
<span class="token string">'render functions, or use the compiler-included build.'</span><span class="token punctuation">,</span>
vm
<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment">// 没有获取到vue的模板文件</span>
<span class="token function">warn</span><span class="token punctuation">(</span>
<span class="token string">'Failed to mount component: template or render function not defined.'</span><span class="token punctuation">,</span>
vm
<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 执行beforeMount钩子</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeMount'</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> updateComponent
<span class="token operator">/</span> istanbul ignore <span class="token keyword">if</span> <span class="token operator">/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> vm<span class="token punctuation">.</span>_name
<span class="token keyword">const</span> id <span class="token operator">=</span> vm<span class="token punctuation">.</span>_uid
<span class="token keyword">const</span> startTag <span class="token operator">=</span> vue<span class="token operator">-</span>perf<span class="token operator">-</span>start<span class="token operator">:</span>$<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
<span class="token keyword">const</span> endTag <span class="token operator">=</span> vue<span class="token operator">-</span>perf<span class="token operator">-</span>end<span class="token operator">:</span>$<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span>
<span class="token keyword">const</span> vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span>
<span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> render</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span>

<span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span>
vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span>
<span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> patch</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment">// 定义更新函数</span>
<span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">// 实际调⽤是在lifeCycleMixin中定义的update和renderMixin中定义的render</span>
vm<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// we set this to vm._watcher inside the watcher's constructor</span>
<span class="token comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span>
<span class="token comment">// component's mounted hook), which relies on vm._watcher being already defined</span>
<span class="token comment">// 监听当前组件状态，当有数据变化时，更新组件</span>
<span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
<span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 数据更新引发的组件更新</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token operator">/</span> isRenderWatcher <span class="token operator">/</span><span class="token punctuation">)</span>
hydrating <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token comment">// manually mounted instance, call mounted on self</span>
<span class="token comment">// mounted is called for render-created child components in its inserted hook</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'mounted'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> vm
<span class="token punctuation">}</span>
</code></pre></div><p>阅读上面代码，我们得到以下结论：
会触发beforeCreate钩子
定义updateComponent渲染页面视图的方法
监听组件数据，一旦发生变化，触发beforeUpdate生命钩子
updateComponent方法主要执行在vue初始化时声明的render，update方法
render的作用主要是生成vnode
源码位置：src\core\instance\render.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义vue 原型上的render方法</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token literal-property property">vm</span><span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token comment">// render函数来自于组件的option</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> _parentVnode <span class="token punctuation">}</span> <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">$optionsif</span> <span class="token punctuation">(</span><span class="token parameter">_parentVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>$scopedSlots <span class="token operator">=</span> <span class="token function">normalizeScopedSlots</span><span class="token punctuation">(</span>
      _parentVnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>scopedSlots<span class="token punctuation">,</span>
      vm<span class="token punctuation">.</span>$slots<span class="token punctuation">,</span>
      vm<span class="token punctuation">.</span>$scopedSlots
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// set parent vnode. this allows render functions to have access</span>
  <span class="token comment">// to the data on the placeholder node.</span>
  vm<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> _parentVnode
  <span class="token comment">// render self</span>
  <span class="token keyword">let</span> vnode
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// There's no need to maintain a stack because all render fns are called</span>
    <span class="token comment">// separately from one another. Nested component's render fns are called</span>
    <span class="token comment">// when parent component is patched.</span>
    currentRenderingInstance <span class="token operator">=</span> vm
    <span class="token comment">// 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode</span>
    vnode <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">render</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token comment">// return error render result,</span>
    <span class="token comment">// or previous vnode to prevent render error causing blank component</span>
    <span class="token comment">/* istanbul ignore else */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>renderError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span><span class="token function">renderError</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">,</span> e<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">renderError</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    currentRenderingInstance <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// if the returned array contains only a single node, allow it</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vnode <span class="token operator">=</span> vnode<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// return empty vnode in case the render function errored out</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>vnode <span class="token keyword">instanceof</span> <span class="token class-name">VNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token string">'Multiple root nodes returned from render function. Render function '</span> <span class="token operator">+</span>
        <span class="token string">'should return a single root node.'</span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    vnode <span class="token operator">=</span> <span class="token function">createEmptyVNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// set parent</span>
  vnode<span class="token punctuation">.</span>parent <span class="token operator">=</span> _parentVnode
<span class="token keyword">return</span> vnode<span class="token punctuation">}</span>
</code></pre></div><p>_update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中
源码位置：src\core\instance\lifecycle.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vnode</span><span class="token operator">:</span> VNode<span class="token punctuation">,</span> hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">const</span> <span class="token literal-property property">vm</span><span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
<span class="token keyword">const</span> prevEl <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el
    <span class="token keyword">const</span> prevVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode
    <span class="token comment">// 设置当前激活的作用域</span>
    <span class="token keyword">const</span> restoreActiveInstance <span class="token operator">=</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> vnode
    <span class="token comment">// Vue.prototype.__patch__ is injected in entry points</span>
    <span class="token comment">// based on the rendering backend used.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// initial render</span>
      <span class="token comment">// 执行具体的挂载逻辑</span>
      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">patch</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* removeOnly */</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// updates</span>
      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">patch</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">restoreActiveInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// update vue reference</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>prevEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
prevEl<span class="token punctuation">.</span>vue <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>vue <span class="token operator">=</span> vm
<span class="token punctuation">}</span>
<span class="token comment">// if parent is an HOC, update its $el as well</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$vnode <span class="token operator">===</span> vm<span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>_vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el
<span class="token punctuation">}</span>
<span class="token comment">// updated hook is called by the scheduler to ensure that children are</span>
<span class="token comment">// updated in a parent's updated hook.</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id=""><a href="#" class="header-anchor">#</a></h3> <p>#二、结论
new Vue的时候调用会调用_init方法
定义 $set、$get 、$delete、$watch 等方法
定义 $on、$off、$emit、$off等事件
定义 _update、$forceUpdate、$destroy生命周期
调用$mount进行页面的挂载
挂载的时候主要是通过mountComponent方法
定义updateComponent更新函数
执行render生成虚拟DOM
_update将虚拟DOM生成真实DOM结构，并且渲染到页面中</p> <h2 id="_40-spa首屏加载速度慢的怎么解决"><a href="#_40-spa首屏加载速度慢的怎么解决" class="header-anchor">#</a> 40. 	SPA首屏加载速度慢的怎么解决？</h2> <h3 id="原因"><a href="#原因" class="header-anchor">#</a> 原因：</h3> <p>在页面渲染的过程，导致加载速度慢的因素可能如下：</p> <ul><li>网络延时问题</li> <li>资源文件体积是否过大</li> <li>资源是否重复发送请求去加载了</li> <li>加载脚本的时候，渲染内容堵塞了</li></ul> <h3 id="解决方法"><a href="#解决方法" class="header-anchor">#</a> 解决方法：</h3> <p>常见的几种SPA首屏优化方式</p> <ul><li>减小入口文件积</li> <li>静态资源本地缓存</li> <li>UI框架按需加载</li> <li>图片资源的压缩</li> <li>组件重复打包</li> <li>开启GZip压缩</li> <li>使用SSR</li></ul> <p>减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化
下图是更为全面的首屏优化的方案：
<img src="https://cdn.nlark.com/yuque/0/2022/png/21986664/1656422763050-af62ef92-06e8-4c48-bab4-80ee00bfc48b.png#clientId=u7ad4c13a-dd78-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=u14f8c9e5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=433&amp;originWidth=1080&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=104433&amp;status=done&amp;style=none&amp;taskId=u707e2f86-00b5-4a69-aca2-9d4e14b9740&amp;title=&amp;width=540" alt="image.png"></p> <h2 id="_41-动态给vue的data添加一个新的属性时会发生什么-怎样解决"><a href="#_41-动态给vue的data添加一个新的属性时会发生什么-怎样解决" class="header-anchor">#</a> 41.动态给vue的data添加一个新的属性时会发生什么？怎样解决？</h2> <h3 id="一、直接添加属性问题"><a href="#一、直接添加属性问题" class="header-anchor">#</a> 一、直接添加属性问题</h3> <p>我们从一个例子开始
定义一个p标签，通过v-for指令进行遍历
然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>p v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;(value,key) in item&quot;</span> <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;key&quot;</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;addProperty&quot;</span><span class="token operator">&gt;</span>动态添加新属性<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
</code></pre></div><p>实例化一个vue实例，定义data属性和methods方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">&quot;#app&quot;</span><span class="token punctuation">,</span>
   	<span class="token function-variable function">data</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       	<span class="token literal-property property">item</span><span class="token operator">:</span><span class="token punctuation">{</span>
            <span class="token literal-property property">oldProperty</span><span class="token operator">:</span><span class="token string">&quot;旧属性&quot;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>newProperty <span class="token operator">=</span> <span class="token string">&quot;新属性&quot;</span>  <span class="token comment">// 为items添加新属性</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span>  <span class="token comment">// 输出带有newProperty的items</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>点击按钮，发现结果不及预期，数据虽然更新了（console打印出了新属性），但页面并没有更新。</p> <h3 id="二、原理分析"><a href="#二、原理分析" class="header-anchor">#</a> 二、原理分析</h3> <p>为什么产生上面的情况呢？
下面来分析一下
vue2是用过Object.defineProperty实现数据响应式。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">get foo:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> val
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">!==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">set foo:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                val <span class="token operator">=</span> newVal
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当我们访问foo属性或者设置foo值的时候都能够触发setter与getter</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span>foo   
obj<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'new'</span>
</code></pre></div><p>但是我们为obj添加新属性的时候，却无法触发事件属性的拦截。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span>bar  <span class="token operator">=</span> <span class="token string">'新属性'</span>
</code></pre></div><p>原因是一开始obj的foo属性被设成了响应式数据，而bar是后面新增的属性，并没有通过Object.defineProperty设置成响应式数据。</p> <h3 id="三、解决方案"><a href="#三、解决方案" class="header-anchor">#</a> 三、解决方案</h3> <p>Vue 不允许在已经创建的实例上动态添加新的响应式属性
若想实现数据与视图同步更新，可采取下面三种解决方案：</p> <ul><li>Vue.set()</li> <li>Object.assign()</li> <li>$forcecUpdated()</li></ul> <h4 id="vue-set"><a href="#vue-set" class="header-anchor">#</a> <a href="http://fanyouf.gitee.io/interview/vue/data_object_add_attrs.html#vue-set" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>Vue.set()</h4> <p>Vue.set( target, propertyName/index, value )
参数</p> <ul><li>{Object | Array} target</li> <li>{string | number} propertyName/index</li> <li>{any} value</li></ul> <p>返回值：设置的值
通过Vue.set向响应式对象中添加一个property，并确保这个新 property同样是响应式的，且触发视图更新
关于Vue.set源码（省略了很多与本节不相关的代码）
源码位置：src\core\observer\index.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">set</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">target</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token literal-property property">val</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre></div><p>这里无非再次调用defineReactive方法，实现新增属性的响应式
关于defineReactive方法，内部还是通过Object.defineProperty实现属性拦截
大致代码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">get </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> val
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">!==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">set </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                val <span class="token operator">=</span> newVal
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="object-assign"><a href="#object-assign" class="header-anchor">#</a> Object.assign()</h4> <p>直接使用Object.assign()添加到对象的新属性不会触发更新
应创建一个新的对象，合并原对象和混入对象的属性</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>someObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObject<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">newProperty1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">newProperty2</span><span class="token operator">:</span><span class="token number">2</span> <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="forceupdate"><a href="#forceupdate" class="header-anchor">#</a> $forceUpdate</h4> <p>如果你发现你自己需要在 Vue中做一次强制更新，99.9% 的情况，是你在某个地方做错了事
$forceUpdate迫使Vue 实例重新渲染
PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p> <h3 id="四、小结"><a href="#四、小结" class="header-anchor">#</a> 四、小结</h3> <ul><li>如果为对象添加少量的新属性，可以直接采用Vue.set()</li> <li>如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象</li> <li>如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议)</li></ul> <p>PS：vue3是用过proxy实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p> <h2 id="_42-说说你对vue中的mixin的理解-有什么应用场景"><a href="#_42-说说你对vue中的mixin的理解-有什么应用场景" class="header-anchor">#</a> 42.说说你对vue中的mixin的理解，有什么应用场景？</h2> <p>Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类
Mixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂
本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods、created、computed等等
我们只要将共用的功能以对象的方式传入 mixin选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来
在Vue中我们可以<strong>局部混入</strong>跟<strong>全局混入。</strong>
局部混入：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'componentA'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span>myMixin<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>全局混入：（使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件））
PS：全局混入常用于插件的编写</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;全局混入&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项：</h3> <p>当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项
但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子</p> <h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景：</h3> <p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立。
这时，可以通过Vue的mixin功能将相同或者相似的代码提出来。</p> <h2 id="_43-说说vue中的diff算法。"><a href="#_43-说说vue中的diff算法。" class="header-anchor">#</a> 43.说说vue中的diff算法。</h2> <h3 id="一、是什么"><a href="#一、是什么" class="header-anchor">#</a> 一、是什么</h3> <p>diff 算法是一种通过同层的树节点进行比较的高效算法
其有两个特点：</p> <ul><li>比较只会在同层级进行, 不会跨层级比较</li> <li>在diff比较的过程中，循环从两边向中间比较</li></ul> <p>diff 算法的在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较</p> <h3 id="二、比较方式"><a href="#二、比较方式" class="header-anchor">#</a> 二、比较方式</h3> <p>diff整体策略为：深度优先，同层比较</p> <ol><li>比较只会在同层级进行, 不会跨层级比较</li> <li>比较的过程中，循环从两边向中间收拢</li></ol> <p>下面举个vue通过diff算法更新的例子：
新旧VNode节点如下图所示：
第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点endIndex移动到C，新节点的 startIndex 移动到了 C
第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E
第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动
第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的startIndex 移动到了 B
第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F
新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面</p> <h3 id="三、原理分析"><a href="#三、原理分析" class="header-anchor">#</a> 三、原理分析</h3> <p>当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图
源码位置：src/core/vdom/patch.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">functionpatch</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 没有新节点，直接执行destory钩子函数if(isDef(oldVnode))invokeDestroyHook(oldVnode)return}let isInitialPatch =falseconst insertedVnodeQueue =[]if(isUndef(oldVnode)){ isInitialPatch =truecreateElm(vnode, insertedVnodeQueue)// 没有旧节点，直接用新节点生成dom元素}else{const isRealElement =isDef(oldVnode.nodeType)if(!isRealElement &amp;&amp;sameVnode(oldVnode, vnode)){// 判断旧节点和新节点自身一样，一致执行patchVnodepatchVnode(oldVnode, vnode, insertedVnodeQueue,null,null, removeOnly)}else{// 否则直接销毁及旧节点，根据新节点生成dom元素if(isRealElement){if(oldVnode.nodeType ===1&amp;&amp; oldVnode.hasAttribute(SSR_ATTR)){ oldVnode.removeAttribute(SSR_ATTR) hydrating =true}if(isTrue(hydrating)){if(hydrate(oldVnode, vnode, insertedVnodeQueue)){invokeInsertHook(vnode, insertedVnodeQueue,true)return oldVnode }} oldVnode =emptyNodeAt(oldVnode)}return vnode.elm }}}</span>
</code></pre></div><p>patch函数前两个参数位为oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：
没有新节点，直接触发旧节点的destory钩子
没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm
旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点
旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点
下面主要讲的是patchVnode部分</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">functionpatchVnode</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 如果新旧节点一致，什么都不做if(oldVnode === vnode){return}// 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化const elm = vnode.elm = oldVnode.elm // 异步占位符if(isTrue(oldVnode.isAsyncPlaceholder)){if(isDef(vnode.asyncFactory.resolved)){hydrate(oldVnode.elm, vnode, insertedVnodeQueue)}else{ vnode.isAsyncPlaceholder =true}return}// 如果新旧都是静态节点，并且具有相同的key// 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上// 也不用再有其他操作if(isTrue(vnode.isStatic)&amp;&amp;isTrue(oldVnode.isStatic)&amp;&amp; vnode.key === oldVnode.key &amp;&amp;(isTrue(vnode.isCloned)||isTrue(vnode.isOnce))){ vnode.componentInstance = oldVnode.componentInstance return}let i const data = vnode.data if(isDef(data)&amp;&amp;isDef(i = data.hook)&amp;&amp;isDef(i = i.prepatch)){i(oldVnode, vnode)}const oldCh = oldVnode.children const ch = vnode.children if(isDef(data)&amp;&amp;isPatchable(vnode)){for(i =0; i &lt; cbs.update.length;++i) cbs.update[i](oldVnode, vnode)if(isDef(i = data.hook)&amp;&amp;isDef(i = i.update))i(oldVnode, vnode)}// 如果vnode不是文本节点或者注释节点if(isUndef(vnode.text)){// 并且都有子节点if(isDef(oldCh)&amp;&amp;isDef(ch)){// 并且子节点不完全一致，则调用updateChildrenif(oldCh !== ch)updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)// 如果只有新的vnode有子节点}elseif(isDef(ch)){if(isDef(oldVnode.text)) nodeOps.setTextContent(elm,'')// elm已经引用了老的dom节点，在老的dom节点上添加子节点addVnodes(elm,null, ch,0, ch.length -1, insertedVnodeQueue)// 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh}elseif(isDef(oldCh)){removeVnodes(elm, oldCh,0, oldCh.length -1)// 如果老节点是文本节点}elseif(isDef(oldVnode.text)){ nodeOps.setTextContent(elm,'')}// 如果新vnode和老vnode是文本节点或注释节点// 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以}elseif(oldVnode.text !== vnode.text){ nodeOps.setTextContent(elm, vnode.text)}if(isDef(data)){if(isDef(i = data.hook)&amp;&amp;isDef(i = i.postpatch))i(oldVnode, vnode)}}</span>
</code></pre></div><p>patchVnode主要做了几个判断：
新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容
新节点和旧节点如果都有子节点，则处理比较更新子节点
只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点
只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除
子节点不完全一致，则调用updateChildren</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">functionupdateChildren</span><span class="token punctuation">(</span><span class="token parameter">parentElm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">let</span> oldStartIdx <span class="token operator">=</span><span class="token number">0</span><span class="token comment">// 旧头索引let newStartIdx =0// 新头索引let oldEndIdx = oldCh.length -1// 旧尾索引let newEndIdx = newCh.length -1// 新尾索引let oldStartVnode = oldCh[0]// oldVnode的第一个childlet oldEndVnode = oldCh[oldEndIdx]// oldVnode的最后一个childlet newStartVnode = newCh[0]// newVnode的第一个childlet newEndVnode = newCh[newEndIdx]// newVnode的最后一个childlet oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by &lt;transition-group&gt;// to ensure removed elements stay in correct relative positions// during leaving transitionsconst canMove =!removeOnly // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束while(oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx){// 如果oldVnode的第一个child不存在if(isUndef(oldStartVnode)){// oldStart索引右移 oldStartVnode = oldCh[++oldStartIdx]// Vnode has been moved left// 如果oldVnode的最后一个child不存在}elseif(isUndef(oldEndVnode)){// oldEnd索引左移 oldEndVnode = oldCh[--oldEndIdx]// oldStartVnode和newStartVnode是同一个节点}elseif(sameVnode(oldStartVnode, newStartVnode)){// patch oldStartVnode和newStartVnode， 索引左移，继续循环patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx]// oldEndVnode和newEndVnode是同一个节点}elseif(sameVnode(oldEndVnode, newEndVnode)){// patch oldEndVnode和newEndVnode，索引右移，继续循环patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx]// oldStartVnode和newEndVnode是同一个节点}elseif(sameVnode(oldStartVnode, newEndVnode)){// Vnode moved right// patch oldStartVnode和newEndVnodepatchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)// 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))// oldStart索引右移，newEnd索引左移 oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx]// 如果oldEndVnode和newStartVnode是同一个节点}elseif(sameVnode(oldEndVnode, newStartVnode)){// Vnode moved left// patch oldEndVnode和newStartVnodepatchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)// 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)// oldEnd索引左移，newStart索引右移 oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx]// 如果都不匹配}else{if(isUndef(oldKeyToIdx)) oldKeyToIdx =createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)// 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode idxInOld =isDef(newStartVnode.key)? oldKeyToIdx[newStartVnode.key]:findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)// 如果未找到，说明newStartVnode是一个新的节点if(isUndef(idxInOld)){// New element// 创建一个新VnodecreateElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)// 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove}else{ vnodeToMove = oldCh[idxInOld]/* istanbul ignore if */if(process.env.NODE_ENV!=='production'&amp;&amp;!vnodeToMove){warn('It seems there are duplicate keys that is causing an update error. '+'Make sure each v-for item has a unique key.')}// 比较两个具有相同的key的新节点是否是同一个节点//不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。if(sameVnode(vnodeToMove, newStartVnode)){// patch vnodeToMove和newStartVnodepatchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)// 清除 oldCh[idxInOld]=undefined// 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm// 移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)// 如果key相同，但是节点不相同，则创建一个新的节点}else{// same key but different element. treat as new elementcreateElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)}}// 右移 newStartVnode = newCh[++newStartIdx]}}</span>
</code></pre></div><p>while循环主要处理了以下五种情景：
当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1
当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1
当老 VNode 节点的 start 和新 VNode 节点的 end相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1
当老 VNode 节点的 end 和新 VNode 节点的 start相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1
如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：
从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行patchVnode ，同时将这个真实 dom 移动到 oldStartVnode 对应的真实 dom的前面
调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置</p> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁
通过isSameVnode进行判断，相同则调用patchVnode方法
patchVnode做了以下操作：
找到对应的真实dom，称为el
如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点
如果oldVnode有子节点而VNode没有，则删除el子节点
如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el
如果两者都有子节点，则执行updateChildren函数比较子节点
updateChildren主要做了以下操作：
设置新旧VNode的头尾指针
新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作</p> <h2 id="_44-什么是虚拟dom-如何实现一个虚拟dom-说说你的思路。"><a href="#_44-什么是虚拟dom-如何实现一个虚拟dom-说说你的思路。" class="header-anchor">#</a> 44.什么是虚拟dom，如何实现一个虚拟dom？说说你的思路。</h2> <h3 id="一、什么是虚拟dom"><a href="#一、什么是虚拟dom" class="header-anchor">#</a> 一、什么是虚拟dom</h3> <p>虚拟 DOM （Virtual DOM ）这个概念相信大家都不陌生，从 React 到 Vue ，虚拟 DOM 为这两个框架都带来了跨平台的能力（React-Native 和 Weex）
实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上
在Javascript对象中，虚拟DOM 表现为一个 Object 对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别
创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应
在vue中同样使用到了虚拟DOM技术。
定义真实dom：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;p&quot;</span><span class="token operator">&gt;</span>节点内容<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h3<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> foo <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><p>实例化vue：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">&quot;#app&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token literal-property property">foo</span><span class="token operator">:</span><span class="token string">&quot;foo&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>观察render的render，我们能得到虚拟dom：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">anonymous</span><span class="token punctuation">(</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">attrs</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string-property property">&quot;id&quot;</span><span class="token operator">:</span><span class="token string">&quot;app&quot;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">staticClass</span><span class="token operator">:</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                      <span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">&quot;节点内容&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'h3'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>通过VNode，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能</p> <h3 id="二、为什么需要虚拟dom"><a href="#二、为什么需要虚拟dom" class="header-anchor">#</a> 二、为什么需要虚拟dom？</h3> <p>DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的	
当你在一次操作时，需要更新10个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程
而通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算。
<img src="https://cdn.nlark.com/yuque/0/2022/png/21986664/1656424146214-8494b3e1-bb29-4d51-aa5d-7168d645b030.png#clientId=u7ad4c13a-dd78-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=149&amp;id=u922af71d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=722&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=106014&amp;status=done&amp;style=none&amp;taskId=ub83e5052-79dd-4934-a6c0-10e63af7f87&amp;title=&amp;width=361" alt="image.png"></p> <h3 id="三、如何实现虚拟dom"><a href="#三、如何实现虚拟dom" class="header-anchor">#</a> 三、如何实现虚拟dom？</h3> <p>首先可以看看vue中VNode的结构
源码位置：src/core/vdom/vnode.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">VNode</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> VNodeData <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token literal-property property">text</span><span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token literal-property property">elm</span><span class="token operator">:</span> Node <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token literal-property property">ns</span><span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token literal-property property">context</span><span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// rendered in this component's scope</span>
  <span class="token literal-property property">functionalContext</span><span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// only for functional component root nodes</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> string <span class="token operator">|</span> number <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token literal-property property">componentOptions</span><span class="token operator">:</span> VNodeComponentOptions <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token literal-property property">componentInstance</span><span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// component instance</span>
  <span class="token literal-property property">parent</span><span class="token operator">:</span> VNode <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// component placeholder node</span>
  <span class="token literal-property property">raw</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// contains raw HTML? (server only)</span>
  <span class="token literal-property property">isStatic</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// hoisted static node</span>
  <span class="token literal-property property">isRootInsert</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// necessary for enter transition check</span>
  <span class="token literal-property property">isComment</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// empty comment placeholder?</span>
  <span class="token literal-property property">isCloned</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// is a cloned node?</span>
  <span class="token literal-property property">isOnce</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// is a v-once node?</span>

  <span class="token function">constructor</span> <span class="token punctuation">(</span>
    <span class="token parameter">tag<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
    data<span class="token operator">?</span><span class="token operator">:</span> VNodeData<span class="token punctuation">,</span>
    children<span class="token operator">?</span><span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    text<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
    elm<span class="token operator">?</span><span class="token operator">:</span> Node<span class="token punctuation">,</span>
    context<span class="token operator">?</span><span class="token operator">:</span> Component<span class="token punctuation">,</span>
    componentOptions<span class="token operator">?</span><span class="token operator">:</span> VNodeComponentOptions</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*当前节点的标签名*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag
    <span class="token comment">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data
    <span class="token comment">/*当前节点的子节点，是一个数组*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> children
    <span class="token comment">/*当前节点的文本*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> text
    <span class="token comment">/*当前虚拟节点对应的真实dom节点*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>elm <span class="token operator">=</span> elm
    <span class="token comment">/*当前节点的名字空间*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ns <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/*编译作用域*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context
    <span class="token comment">/*函数化组件作用域*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>functionalContext <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/*节点的key属性，被当作节点的标志，用以优化*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>key
    <span class="token comment">/*组件的option选项*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>componentOptions <span class="token operator">=</span> componentOptions
    <span class="token comment">/*当前节点对应的组件的实例*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/*当前节点的父节点*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>raw <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/*静态节点标志*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isStatic <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/*是否作为跟节点插入*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isRootInsert <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">/*是否为注释节点*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isComment <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/*是否为克隆节点*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isCloned <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/*是否有v-once指令*/</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isOnce <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// DEPRECATED: alias for componentInstance for backwards compat.</span>
  <span class="token comment">/* istanbul ignore next https://github.com/answershuto/learnVue*/</span>
  <span class="token keyword">get</span> <span class="token function">child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>componentInstance
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里对VNode进行稍微的说明：</p> <ul><li>所有对象的 context 选项都指向了 Vue 实例</li> <li>elm 属性则指向了其相对应的真实 DOM 节点</li></ul> <p>vue是通过createElement生成VNode
源码位置：src/core/vdom/create-element.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createElement</span> <span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">context</span><span class="token operator">:</span> Component<span class="token punctuation">,</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">normalizationType</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">alwaysNormalize</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token operator">|</span> Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPrimitive</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    normalizationType <span class="token operator">=</span> children
    children <span class="token operator">=</span> data
    data <span class="token operator">=</span> <span class="token keyword">undefined</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>alwaysNormalize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    normalizationType <span class="token operator">=</span> <span class="token constant">ALWAYS_NORMALIZE</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_createElement</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span> normalizationType<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面可以看到createElement 方法实际上是对 _createElement 方法的封装，对参数的传入进行了判断</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">_createElement</span><span class="token punctuation">(</span>
    <span class="token parameter"><span class="token literal-property property">context</span><span class="token operator">:</span> Component<span class="token punctuation">,</span>
    tag<span class="token operator">?</span><span class="token operator">:</span> string <span class="token operator">|</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span> <span class="token operator">|</span> Function <span class="token operator">|</span> Object<span class="token punctuation">,</span>
    data<span class="token operator">?</span><span class="token operator">:</span> VNodeData<span class="token punctuation">,</span>
    children<span class="token operator">?</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
    normalizationType<span class="token operator">?</span><span class="token operator">:</span> number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token operator">|</span> Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
            <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Avoid using observed data object as vnode data: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\n</span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
            <span class="token string">'Always create fresh vnode data objects in each render!'</span><span class="token punctuation">,</span>
            context`
        <span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">createEmptyVNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// object syntax in v-bind</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tag <span class="token operator">=</span> data<span class="token punctuation">.</span>is
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// in case of component :is set to falsy value</span>
        <span class="token keyword">return</span> <span class="token function">createEmptyVNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span> 
    <span class="token comment">// support single function children as default scoped slot</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token keyword">typeof</span> children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'function'</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        data <span class="token operator">=</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        data<span class="token punctuation">.</span>scopedSlots <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token operator">:</span> children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
        children<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>normalizationType <span class="token operator">===</span> <span class="token constant">ALWAYS_NORMALIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        children <span class="token operator">=</span> <span class="token function">normalizeChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">===</span> <span class="token constant">SIMPLE_NORMALIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        children <span class="token operator">=</span> <span class="token function">simpleNormalizeChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 创建VNode</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到_createElement接收5个参数：</p> <ul><li>context 表示 VNode 的上下文环境，是 Component类型</li> <li>tag 表示标签，它可以是一个字符串，也可以是一个 Component</li> <li>data 表示 VNode 的数据，它是一个 VNodeData 类型</li> <li>children 表示当前 VNode 的子节点，它是任意类型的</li> <li>normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 render 函数是编译生成的还是用户手写的</li></ul> <p>根据normalizationType 的类型，children会有不同的定义</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>normalizationType <span class="token operator">===</span> <span class="token constant">ALWAYS_NORMALIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    children <span class="token operator">=</span> <span class="token function">normalizeChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">===</span> <span class="token constant">SIMPLE_NORMALIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    children <span class="token operator">=</span> <span class="token function">simpleNormalizeChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>simpleNormalizeChildren方法调用场景是 render 函数是编译生成的
normalizeChildren方法调用场景分为下面两种：</p> <ul><li>render 函数是用户手写的</li> <li>编译 slot、v-for 的时候会产生嵌套数组</li></ul> <p>无论是simpleNormalizeChildren还是normalizeChildren都是对children进行规范（使children 变成了一个类型为 VNode 的 Array），这里就不展开说了
规范化children的源码位置在：src/core/vdom/helpers/normalzie-children.js
在规范化children后，就去创建VNode</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> vnode<span class="token punctuation">,</span> ns
<span class="token comment">// 对tag进行判断</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> Ctor
  ns <span class="token operator">=</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>$vnode <span class="token operator">&amp;&amp;</span> context<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>ns<span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">getTagNamespace</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isReservedTag</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果是内置的节点，则直接创建一个普通VNode</span>
    vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
      config<span class="token punctuation">.</span><span class="token function">parsePlatformTagName</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span>
      <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> context
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>Ctor <span class="token operator">=</span> <span class="token function">resolveAsset</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>$options<span class="token punctuation">,</span> <span class="token string">'components'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// component</span>
    <span class="token comment">// 如果是component类型，则会通过createComponent创建VNode节点</span>
    vnode <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">,</span> data<span class="token punctuation">,</span> context<span class="token punctuation">,</span> children<span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
      tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span>
      <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> context
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// direct component options / constructor</span>
  vnode <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> context<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>createComponent同样是创建VNode
源码位置：src/core/vdom/create-component.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createComponent</span> <span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">Ctor</span><span class="token operator">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span> <span class="token operator">|</span> Function <span class="token operator">|</span> Object <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token operator">?</span>VNodeData<span class="token punctuation">,</span>
  <span class="token literal-property property">context</span><span class="token operator">:</span> Component<span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  tag<span class="token operator">?</span><span class="token operator">:</span> string</span>
<span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token operator">|</span> Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
 <span class="token comment">// 构建子类构造函数 </span>
  <span class="token keyword">const</span> baseCtor <span class="token operator">=</span> context<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_base

  <span class="token comment">// plain options object: turn it into a constructor</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Ctor <span class="token operator">=</span> baseCtor<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// if at this stage it's not a constructor or an async component factory,</span>
  <span class="token comment">// reject.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Ctor <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Invalid Component definition: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">String</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// async component</span>
  <span class="token keyword">let</span> asyncFactory
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>cid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    asyncFactory <span class="token operator">=</span> Ctor
    Ctor <span class="token operator">=</span> <span class="token function">resolveAsyncComponent</span><span class="token punctuation">(</span>asyncFactory<span class="token punctuation">,</span> baseCtor<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Ctor <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">createAsyncPlaceholder</span><span class="token punctuation">(</span>
        asyncFactory<span class="token punctuation">,</span>
        data<span class="token punctuation">,</span>
        context<span class="token punctuation">,</span>
        children<span class="token punctuation">,</span>
        tag
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  data <span class="token operator">=</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// resolve constructor options in case global mixins are applied after</span>
  <span class="token comment">// component constructor creation</span>
  <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span>

  <span class="token comment">// transform component v-model data into props &amp; events</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">transformModel</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>options<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// extract props</span>
  <span class="token keyword">const</span> propsData <span class="token operator">=</span> <span class="token function">extractPropsFromVNodeData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> Ctor<span class="token punctuation">,</span> tag<span class="token punctuation">)</span>

  <span class="token comment">// functional component</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>options<span class="token punctuation">.</span>functional<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createFunctionalComponent</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> data<span class="token punctuation">,</span> context<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// extract listeners, since these needs to be treated as</span>
  <span class="token comment">// child component listeners instead of DOM listeners</span>
  <span class="token keyword">const</span> listeners <span class="token operator">=</span> data<span class="token punctuation">.</span>on
  <span class="token comment">// replace with listeners with .native modifier</span>
  <span class="token comment">// so it gets processed during parent component patch.</span>
  data<span class="token punctuation">.</span>on <span class="token operator">=</span> data<span class="token punctuation">.</span>nativeOn

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> slot <span class="token operator">=</span> data<span class="token punctuation">.</span>slot
    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      data<span class="token punctuation">.</span>slot <span class="token operator">=</span> slot
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 安装组件钩子函数，把钩子函数合并到data.hook中</span>
  <span class="token function">installComponentHooks</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>

  <span class="token comment">//实例化一个VNode返回。组件的VNode是没有children的</span>
  <span class="token keyword">const</span> name <span class="token operator">=</span> Ctor<span class="token punctuation">.</span>options<span class="token punctuation">.</span>name <span class="token operator">||</span> tag
  <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-component-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Ctor<span class="token punctuation">.</span>cid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">''</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    data<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>
    <span class="token punctuation">{</span> Ctor<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>
    asyncFactory
  <span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__WEEX__ <span class="token operator">&amp;&amp;</span> <span class="token function">isRecyclableComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">renderRecyclableComponentTemplate</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div><p>稍微提下createComponent生成VNode的三个关键流程：</p> <ul><li>构造子类构造函数Ctor</li> <li>installComponentHooks安装组件钩子函数</li> <li>实例化 vnode</li></ul> <h3 id="小结-2"><a href="#小结-2" class="header-anchor">#</a> 小结</h3> <p>createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构。</p> <h2 id="-2"><a href="#-2" class="header-anchor">#</a></h2> <h2 id="-3"><a href="#-3" class="header-anchor">#</a></h2> <h2 id="-4"><a href="#-4" class="header-anchor">#</a></h2> <h2 id="-5"><a href="#-5" class="header-anchor">#</a></h2> <h2 id="-6"><a href="#-6" class="header-anchor">#</a></h2> <h2 id="-7"><a href="#-7" class="header-anchor">#</a></h2> <h2 id="-8"><a href="#-8" class="header-anchor">#</a></h2> <h2 id="-9"><a href="#-9" class="header-anchor">#</a></h2> <h2 id="-10"><a href="#-10" class="header-anchor">#</a></h2> <h2 id="-11"><a href="#-11" class="header-anchor">#</a></h2> <h2 id="-12"><a href="#-12" class="header-anchor">#</a></h2> <h2 id="-13"><a href="#-13" class="header-anchor">#</a></h2> <div class="language- extra-class"><pre><code>问题描述：
</code></pre></div><p>1
、单位贴右边框了，往左移动
15px
2
、红框处间距有点大，改为
30px
3
、星星
icon
看着像有个描边，需要换一个（找设计重新切图）	
问题描述：
1
、单位贴右边框了，往左移动
15px
2
、红框处间距有点大，改为
30px
3
、星星
icon
看着像有个描边，需要换一个（找设计重新切图）</p> <h2 id="-14"><a href="#-14" class="header-anchor">#</a></h2> <h2 id="-15"><a href="#-15" class="header-anchor">#</a></h2> <h2 id="-16"><a href="#-16" class="header-anchor">#</a></h2> <h2 id="-17"><a href="#-17" class="header-anchor">#</a></h2></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/learn/handbook/js.html" class="prev">
          Js面试题
        </a></span> <!----></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:0;" data-v-ac050c62></ul></main></div> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/learn/assets/js/app.250e2cfc.js" defer></script><script src="/learn/assets/js/3.51ab3639.js" defer></script><script src="/learn/assets/js/1.504525ea.js" defer></script><script src="/learn/assets/js/13.ba90bc7d.js" defer></script>
  </body>
</html>
